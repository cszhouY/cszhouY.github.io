<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhou Yee&#39;s Blog</title>
  
  
  <link href="https://cszhouy.github.io/atom.xml" rel="self"/>
  
  <link href="https://cszhouy.github.io/"/>
  <updated>2023-05-10T10:26:36.822Z</updated>
  <id>https://cszhouy.github.io/</id>
  
  <author>
    <name>Zhou Yee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机体系结构——记分牌</title>
    <link href="https://cszhouy.github.io/blog/bfcd1b20.html"/>
    <id>https://cszhouy.github.io/blog/bfcd1b20.html</id>
    <published>2023-04-30T10:19:15.000Z</published>
    <updated>2023-05-10T10:26:36.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记分牌算法"><a href="#记分牌算法" class="headerlink" title="记分牌算法"></a>记分牌算法</h1><p>在一个顺序执行的流水线中，每条指令依次发射，且每个流水阶段只有一条指令在运行。这种顺序执行方式存在一个问题：当前一条指令执行周期数较长时（如乘除法指令是加法指令的几十倍、访存指令缓存不命中），后面指令都将停等，尽管它们和前一条指令不存在数据冒险。为了降低这种性能损失，乱序执行的处理器被设计出来。</p><p>在乱序执行中，CPU会将指令分为多个微操作（Micro-operations），并将这些微操作按照指令之间的依赖关系进行调度，以最大化地利用CPU的执行单元。这样可以让CPU在等待某些资源时，可以继续执行其他指令，从而提高CPU的利用率和性能。</p><p>记分牌实际上是一个信息存储单元，它负责记录指令状态、运算功能单元状态和寄存器结果状态，在ID流水段CPU依据这些状态信息检查结构冒险和数据冒险，以此判断是否发射当前指令。</p><p>一个功能单元通常表现为如下形式</p><p><img src="https://pic2.imgdb.cn/item/645b09ff0d2dde5777136709.jpg" alt=""></p><p>有9个字段表示每一个部件的状态：</p><ul><li><code>busy</code>：指示该单元是否繁忙</li><li><code>Op</code>：该单元正在进行的运算类型</li><li><code>Fi</code>：运算结果的目标寄存器</li><li><code>Fj</code>、<code>Fk</code>：源寄存器</li><li><code>Rj</code>、<code>Rk</code>：指示源寄存器<code>Fj</code>、<code>Fk</code>是否准备就绪但尚未读取。在读取操作数后设置为“yes”</li><li><code>Qj</code>、<code>Qk</code>：如果源寄存器<code>Fj</code>、<code>Fk</code>没有准备就绪，那生成它们的值的部件</li></ul><p>一个寄存器结果状态通常表现为如下形式：</p><p><img src="https://pic2.imgdb.cn/item/645b0b2f0d2dde577714841c.jpg" alt=""></p><p>如果一条活动指令以该寄存器为目标寄存器，则指出哪个功能单元将写入每个寄存器。只要没有向该寄存器写入的未完成指令，则将该字段设置为空。</p><h1 id="乱序流水线工作步骤"><a href="#乱序流水线工作步骤" class="headerlink" title="乱序流水线工作步骤"></a>乱序流水线工作步骤</h1><p>为了检查指令之间的结构冒险和数据冒险，需要将ID阶段拆成发射和读取操作数两个阶段，以下四个阶段代替了标准RISCV流水线中的ID、EX和WB步骤：</p><ol><li><strong>发射</strong>：如果指令的一个功能单元空闲（功能部件状态的<code>busy</code>字段），且没有其它活动指令以同一寄存器为目标寄存器（目标寄存器状态是否为空），则记分牌向功能单元发射指令，并更新指令状态。该步骤能解决<strong>结构冒险</strong>和<strong>WRW冒险。</strong></li><li><strong>读取操作数</strong>：如果不存在检查活动指令写入源寄存器（<code>Rj</code>和<code>Rk</code>字段为yes），记分牌将该指令发送到功能部件（<code>Rj</code>和<code>Rk</code>字段标记为no）。该步骤能解决<strong>RAW冒险</strong>。</li><li><strong>执行</strong>：功能单元开始执行对应操作，更新功能单元状态。当结果就绪后，通知记分牌。</li><li><strong>写结果</strong>：当其它活动指令不需要读取当前计算结果即将写入的寄存器，写回寄存器，并清空该条指令在记分牌记录的状态，同时修改以该指令目标寄存器作为源操作数的指令的<code>Rj</code>和<code>Rk</code>字段。该步骤能解决<strong>WAR冒险</strong>。</li></ol><h1 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h1><p>下文演示一个简单的记分牌算法下多条指令乱序执行的案例。</p><blockquote><p><strong><em>Circle 1</em></strong></p></blockquote><p><img src="https://pic2.imgdb.cn/item/645b13b50d2dde57771e911b.jpg" alt=""></p><p>检查记分牌状态，功能部件状态和寄存器状态均为空，第一条指令发射。</p><ul><li>更新结构状态：该指令issue步骤在第 1 个周期执行</li><li>更新功能部件状态：Interger部件开始忙碌，执行load操作，目标寄存器<code>Fi</code>为<code>F6</code>，源寄存器<code>Fk</code>为<code>R2</code>，且<code>R2</code>准备就绪，<code>Rk</code>标记为<code>yes</code></li><li>更新寄存器状态：<code>F6</code>寄存器即将被Integer部件的结果写入</li></ul><blockquote><p><strong><em>Cirlce 2</em></strong></p></blockquote><p><img src="https://pic2.imgdb.cn/item/645b528f0d2dde577769128a.jpg" alt=""></p><p>第一条<code>LD</code>指令进入读操作数步骤，记分牌检查Integer部件非空闲，第二条<code>LD</code>指令不发射。</p><blockquote><p> <strong><em>Circle 3</em></strong></p></blockquote><p><img src="https://pic2.imgdb.cn/item/645b539f0d2dde57776a2ac0.jpg" alt=""></p><p>第一条<code>LD</code>指令进入执行步骤，将<code>Rk</code>标记为no，表示源寄存器<code>Fk</code>读取完成。由第二条<code>LD</code>指令阻塞发射，因此后续的所有指令都无法发射。</p><blockquote><p> <strong><em>Circle 4</em></strong></p></blockquote><p><img src="https://pic2.imgdb.cn/item/645b55dd0d2dde57776c6b72.jpg" alt=""></p><p>第一条<code>LD</code>指令进入写回步骤，将存储器输出值写回寄存器堆，并且清空记分牌。</p><blockquote><p> <strong><em>Circle 5</em></strong></p></blockquote><p><img src="https://pic2.imgdb.cn/item/645b56780d2dde57776d4f84.jpg" alt=""></p><p>检查记分牌状态，Integer部件空闲，寄存器状态中<code>F2</code>字段为空，第二条<code>LD</code>指令发射。</p><ul><li>更新结构状态：该指令issue步骤在第 5 个周期执行</li><li>更新功能部件状态：Interger部件开始忙碌，执行load操作，目标寄存器<code>Fi</code>为<code>F2</code>，源寄存器<code>Fk</code>为<code>R3</code>，且<code>R2</code>准备就绪，<code>Rk</code>标记为<code>yes</code></li><li>更新寄存器状态：<code>F2</code>寄存器即将被Integer部件的结果写入</li></ul><blockquote><p><strong><em>Circle 6</em></strong></p></blockquote><p><img src="https://pic2.imgdb.cn/item/645b57f30d2dde57776fc361.jpg" alt=""></p><p>当前没有活动指令将要写入源寄存器<code>R3</code>, 第二条<code>LD</code>指令进入读操作数阶段。</p><p>检查记分牌状态，Multi部件空闲，寄存器状态中<code>F0</code>字段为空，<code>MULTD</code>指令发射。</p><ul><li>更新结构状态：<code>MULTD</code>指令issue步骤在第 6 个周期执行</li><li>更新功能部件状态：Multi1部件忙碌，执行Multi操作，目标寄存器<code>Fi</code>为<code>F0</code>，源寄存器<code>Fj</code>和<code>Fk</code>为<code>F2</code>和<code>F4</code>，检查寄存器状态，此时源寄存器<code>Fj</code>没有准备就绪，有活动指令将从Integer部件写入，标记<code>Qj</code></li><li>更新寄存器状态：<code>F0</code>即将被Multi1部件写入</li></ul><blockquote><p><strong><em>Circle 7</em></strong></p></blockquote><p><img src="https://pic2.imgdb.cn/item/645b5bea0d2dde5777749a7c.jpg" alt=""></p><p>第二条<code>LD</code>进入执行步骤，将<code>Rk</code>标记为no，表示源寄存器<code>Fk</code>读取完成。<code>MULTD</code>指令的<code>Rj</code>为no，表示源寄存器<code>Fj</code>未准备就绪，无法进入读操作数步骤。</p><p>检查记分牌状态，Add部件空闲，寄存器状态中<code>F8</code>字段为空，<code>SUBD</code>指令发射。</p><ul><li>更新结构状态：<code>SUBD</code>指令issue步骤在第 7 个周期执行</li><li>更新功能部件状态：Add部件忙碌，执行Sub操作，目标寄存器<code>Fi</code>为<code>F8</code>，源寄存器<code>Fj</code>和<code>Fk</code>为<code>F6</code>和<code>F2</code>，检查寄存器状态，此时源寄存器<code>Fk</code>没有准备就绪，有活动指令将从Integer部件写入，标记<code>Qk</code></li><li>更新寄存器状态：<code>F8</code>即将被Add部件写入</li></ul><blockquote><p><strong><em>Circle 8</em></strong></p></blockquote><p>第 8 个周期分为前后半个周期分别分析。</p><p><img src="https://pic2.imgdb.cn/item/645b62bf0d2dde57777b6bdc.jpg" alt=""></p><p>在前半个周期，Divide部件空闲，寄存器状态中<code>F10</code>为空，<code>DIVD</code>指令发射。</p><ul><li>更新结构状态：<code>DIVD</code>指令issue步骤在第 8 个周期执行</li><li>更新功能部件状态：Multi1部件忙碌，执行Multi操作，目标寄存器<code>Fi</code>为<code>F10</code>，源寄存器<code>Fj</code>和<code>Fk</code>为<code>F0</code>和<code>F6</code>，检查寄存器状态，此时源寄存器<code>Fj</code>没有准备就绪，有活动指令将从Integer部件写入，标记<code>Qj</code></li><li>更新寄存器状态：<code>F10</code>即将被Multi1部件写入</li></ul><p><img src="https://pic2.imgdb.cn/item/645b677f0d2dde5777827436.jpg" alt=""></p><p>在后半个周期，第二条指令执行写回步骤，清空它在记分牌中的状态信息，此时寄存器<code>F2</code>已准备就绪，更改功能部件状态中<code>MULTD</code>指令的<code>Qj</code>、<code>Rj</code>字段，<code>SUBD</code>指令的<code>Qk</code>、<code>Rk</code>字段。</p><blockquote><p><strong><em>Circle 9</em></strong></p></blockquote><p><img src="https://pic2.imgdb.cn/item/645b697f0d2dde577784248e.jpg" alt=""></p><p><code>MULTD</code>指令和<code>SUBD</code>指令的源寄存器均已准备就绪且尚未读取，两条指令都进入读操作数步骤。由于Add部件非空闲，<code>ADDD</code>指令不能发射。</p><p>后面的步骤都相似，有时间再慢慢补充。下面是执行完这6条指令记分牌状态：</p><blockquote><p><strong><em>Circle 62</em></strong></p></blockquote><p><img src="https://pic2.imgdb.cn/item/645b6b060d2dde5777856f45.jpg" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/chen0031/Computer-Architecture-A-Quantitative-Approach/blob/master/Book/Computer%20Architecture%20a%20Quantitative%20Approach%206th.pdf">Computer Architecture: A Quantitative Approach 6th Edition</a></li><li><a href="https://zhuanlan.zhihu.com/p/496078836">计算机体系结构-记分牌ScoreBoard</a></li><li><a href="https://en.wikipedia.org/wiki/Scoreboarding">Introduction to Scoreboarding in Wikipedia</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记分牌算法&quot;&gt;&lt;a href=&quot;#记分牌算法&quot; class=&quot;headerlink&quot; title=&quot;记分牌算法&quot;&gt;&lt;/a&gt;记分牌算法&lt;/h1&gt;&lt;p&gt;在一个顺序执行的流水线中，每条指令依次发射，且每个流水阶段只有一条指令在运行。这种顺序执行方式存在一个问题：当前一条</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://cszhouy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://cszhouy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++并发模型：线程池</title>
    <link href="https://cszhouy.github.io/blog/566e7bf0.html"/>
    <id>https://cszhouy.github.io/blog/566e7bf0.html</id>
    <published>2023-04-25T11:41:07.000Z</published>
    <updated>2023-05-05T11:43:55.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池概要"><a href="#线程池概要" class="headerlink" title="线程池概要"></a>线程池概要</h1><p>一个线程池的主要组成部分：</p><ul><li>任务队列：存放Provider分配的任务（task），工作线程不断从队列中取任务并执行。通常被设计为FIFO队列。</li><li>工作线程：多个线程，它们从任务队列获取任务并执行，通常它们的生命周期与线程池相同。工作线程的数目可以是动态的，由程序负载决定。</li><li>管理线程：监测线程池的负载，为了提高线程池运算能力或降低资源开销，适时创建或销毁工作线程。管理线程不是必须的。</li></ul><h1 id="线程安全的队列"><a href="#线程安全的队列" class="headerlink" title="线程安全的队列"></a>线程安全的队列</h1><p>当Provider向任务队列中提供任务、工作线程从队列中取任务时，对同一个资源进行读写操作将会出现冲突，因此需要对原生队列进行包装，实现一个<strong>线程安全</strong>的任务队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeQueue</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> queue_.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> queue_.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp; item)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            queue_.<span class="built_in">emplace</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">        condition_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T &amp;&amp; item)</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            queue_.<span class="built_in">emplace</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>; </span><br><span class="line">        <span class="keyword">if</span> (queue_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item = std::<span class="built_in">move</span>(queue_.<span class="built_in">front</span>()); </span><br><span class="line">        queue_.<span class="built_in">pop</span>(); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wait_pop</span><span class="params">(T &amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>; </span><br><span class="line">        condition_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()&#123; <span class="keyword">return</span> !queue_.<span class="built_in">empty</span>() || stop; &#125;);</span><br><span class="line">        <span class="keyword">if</span> (queue_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item = std::<span class="built_in">move</span>(queue_.<span class="built_in">front</span>()); </span><br><span class="line">        queue_.<span class="built_in">pop</span>(); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; queue_;</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    std::condition_variable condition_;</span><br><span class="line">    <span class="type">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面对SafeQueue中的细节作简要说明：</p><ul><li><code>stop</code>表示该队列（或线程池）是否停止。当线程池停止时，将SafeQueue的<code>stop</code>设为<code>true</code>，此时工作线程停止从队列中取任务。</li><li>在实现入队操作时，重载了两个<code>push</code>函数：<ul><li><code>push(const T &amp;item)</code> 用于将一个左值对象推入队列，其中参数 <code>item</code> 是一个常量左值引用。这意味着 item 的生命周期应大于 <code>push()</code> 函数。</li><li><code>push(T &amp;&amp;item)</code> 用于将一个右值对象推入队列，其中参数 <code>item</code> 是一个右值引用。这意味着 <code>item</code> 的生命周期可以比 <code>push()</code> 函数更短。</li><li>在队列中将右值对象与左值对象区分开来的原因是:右值引用允许快速移动资源所有权，从而避免复制数据和额外的开销。</li></ul></li><li>定义两种类型地出队方式：<ul><li><code>pop()</code>表示非阻塞的从队列中弹出值，当队列为空时线程不会停等，直接返回。</li><li><code>wait_pop()</code>通过条件变量实现阻塞地从队列中取值，只有当队列为空且队列已未停止时将停等。</li></ul></li></ul><h1 id="单队列线程池"><a href="#单队列线程池" class="headerlink" title="单队列线程池"></a>单队列线程池</h1><p>单队列线程池即有多个工作线程和一个任务队列，所有工作线程都从这个任务队列中取任务，这是线程池最简单的一种实现方式。</p><h2 id="初始化线程池"><a href="#初始化线程池" class="headerlink" title="初始化线程池"></a>初始化线程池</h2><p>初始化若干个工作线程，这些线程都在“抢占队列（锁）—&gt;取任务—&gt;执行任务”循环。</p><p>工作线程的数量需要根据应用场景和实际环境进行设计：</p><ul><li>对于IO密集型任务，线程数应该更多，因为这些任务通常需要等待 I/O 操作完成后才能继续执行。如果线程数不足，则会导致线程阻塞，从而降低了程序的整体吞吐量和性能</li><li>对于计算密集型任务，线程数不应该过多，因为这些任务涉及到繁重的计算操作，需要占用 CPU 资源。如果线程数太多，将会大量消耗 CPU 的资源，反而造成系统资源的浪费和降低程序的性能。同时还可以通过实验和性能测试来调整线程池的大小。</li></ul><p>这里将线程个数默认设置为<code>std::thread::hardware_concurrency()</code>，即机器支持的最大并发数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> threads = std::thread::hardware_concurrency())</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i&lt;threads;++i)&#123;</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                <span class="keyword">if</span>(!queue.<span class="built_in">wait_pop</span>(task)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任务入队"><a href="#任务入队" class="headerlink" title="任务入队"></a>任务入队</h2><p>利用模板机制，我们可以将任意可以调用的对象（函数、函数指针、Lambda表达式）作为一个任务，并且参数和返回值没有限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; &gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">    );</span><br><span class="line">    std::future&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    queue.<span class="built_in">push</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>auto -&gt;</code>：<code>auto</code>为自动推导类型，当它作为函数类型时为占位符，<code>-&gt;</code>后为返回值类型。关键字<code>decltype</code>可以获取数据类型。</li><li><code>std::make_shared&lt;T&gt;</code>将返回一个<code>shared_ptr&lt;T&gt;</code>智能指针，指针指向堆空间。这里不能直接使用变量，因为其生存周期要保证到<code>task</code>真正被调用。</li><li><code>std::bind</code>绑定一个可调用对象和参数，生成一个新的可调用对象，调用的结果等同于原调用对象在该参数下的结果。</li><li><code>std::forward</code>会将输入的参数原封不动地传递到下一个函数中，这个“原封不动”指的是，如果输入的参数是左值，那么传递给下一个函数的参数的也是左值；如果输入的参数是右值，那么传递给下一个函数的参数的也是右值。</li><li><code>std::future</code>可以关联线程运行的函数和函数的返回值。<code>std::future</code> 通常由某个 Provider（异步任务提供者） 创建，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 <code>std::future</code> 对象调用 <code>get</code>（通常在另外一个线程中） 获取该值，如果共享状态的标志不为 <code>ready</code>，则调用 <code>std::future::get</code> 会阻塞当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 <code>ready</code>），<code>std::future::get</code> 返回异步任务的值或异常（如果发生了异常）。通过<code>std::future</code>，线程执行函数的返回结果不必保存在全局变量中。</li></ul><h2 id="析构队列"><a href="#析构队列" class="headerlink" title="析构队列"></a>析构队列</h2><p>调用<code>SafeQueue::destory()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">SimplePool</span>()&#123;</span><br><span class="line">    queue.<span class="built_in">destory</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; th : workers)&#123;</span><br><span class="line">        th.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多队列线程池"><a href="#多队列线程池" class="headerlink" title="多队列线程池"></a>多队列线程池</h1><p>传统的单队列线程池有一个瓶颈，当多个工作线程争抢任务时，会先进行加锁，频繁的加锁解锁会有一定的性能开销。为了减少线程之间的竞争，我们可以为每一个工作线程设置一个工作队列，Provider每次将任务随机放到一个队列中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiplePool</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MultiplePool</span><span class="params">(<span class="type">size_t</span> threads = std::thread::hardware_concurrency())</span>: threads_num(threads), queues(threads)&#123;</span></span><br><span class="line">        <span class="keyword">auto</span> worker = [<span class="keyword">this</span>] (<span class="type">size_t</span> i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                <span class="keyword">if</span>(!queues[i].<span class="built_in">wait_pop</span>(task)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">            workers.<span class="built_in">emplace_back</span>(worker, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; &gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        std::future&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        <span class="type">size_t</span> i = <span class="built_in">rand</span>() % threads_num;</span><br><span class="line">        queues[i].<span class="built_in">push</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MultiplePool</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; que : queues) &#123;</span><br><span class="line">            que.<span class="built_in">destory</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; th : workers) &#123;</span><br><span class="line">            th.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers;</span><br><span class="line">    std::vector&lt;SafeQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt;&gt; queues;</span><br><span class="line">    <span class="type">size_t</span> threads_num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="work-stealing"><a href="#work-stealing" class="headerlink" title="work stealing"></a>work stealing</h2><p>多队列线程池存在<strong>负载均衡</strong>的问题。例如有两个线程和两个任务队列，其中队列A有10个<code>1ms</code>的任务，队列B有10个<code>100ms</code>的任务，那么当线程A执行完所有任务后，线程B仍有大量任务未解决；如果线程A挂起，将大大降低线程池的效率。<em>work stealing</em>的主要思路是：<strong>当一个线程执行完自己队列中的任务后，不会立即挂起等待，而是将其它线程的任务队列中未执行的任务“偷过来”执行。</strong></p><p>实现<em>work stealing</em>机制的方法有很多，这这里给出一种简单的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> worker = [<span class="keyword">this</span>] (<span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">while</span>(! stop) &#123;</span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">if</span> (queues[i].<span class="built_in">pop</span>(task) || <span class="built_in">try_steal</span>(task, i)) &#123;</span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意从自己队列取任务使用<code>pop</code>而非<code>wait_pop</code>。<code>WorkStealPool::try_steal</code>是尝试从其它队列偷取任务执行，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_steal</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt;&amp; task, <span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads_num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == index) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (queues[i].<span class="built_in">pop</span>(task)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三种线程池进行比较"><a href="#三种线程池进行比较" class="headerlink" title="三种线程池进行比较"></a>三种线程池进行比较</h1><p>编写一个简单的测试程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kTasks = <span class="number">1000</span>;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kRange = <span class="number">500</span>;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_random</span><span class="params">(<span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> kMaxIterations = <span class="built_in">rand</span>() % <span class="number">50</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kMaxIterations; ++i) &#123;</span><br><span class="line">        val += <span class="built_in">rand</span>() % (kRange / <span class="number">2</span>) - kRange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_threadPool</span><span class="params">(T* pool, <span class="type">const</span> std::string &amp; type )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; kTasks; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> val = i;</span><br><span class="line">        futures.<span class="built_in">emplace_back</span>(pool-&gt;<span class="built_in">submit</span>(add_random, val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; future : futures) &#123;</span><br><span class="line">        future.<span class="built_in">wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> ms = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; type &lt;&lt; <span class="string">&quot; elapsed time: &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MultiplePool elapsed time: 3154ms</span><br><span class="line">WorkStealPool elapsed time: 3109ms</span><br><span class="line">SimplePool elapsed time: 3298ms</span><br></pre></td></tr></table></figure><p>这三种线程池性能在该测试案例下并没有很大区别，甚至当单个任务执行时间相似时（<code>kMaxIterations</code>取常量）<code>WorkStealPool</code>不如<code>MultiplePool</code>。个人分析的原因如下：</p><ul><li><code>SimplePool</code>中的线程获取任务是主动抢占式的，而<code>MultiplePool</code>中的线程获取任务是被动随机分配的。尽管前者会存在更多的线程竞争，但线程执行任务的效率会更高。</li><li><code>WorkStealPool</code>采用的是单头FIFO队列，在获取其它队列的任务时仍然会和原线程存在竞争。而为了减少这种竞争，最好使用双向队列。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/alibaba/async_simple">async_simple</a></li><li><a href="https://changkun.de/modern-cpp/zh-cn/07-thread/"> 现代 C++ 教程：高速上手 C++ 11/14/17/20</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNjA5ODQ0OQ==&amp;mid=2654703194&amp;idx=1&amp;sn=5b411b7d8a3a552e41a6a5a97fa4eeec&amp;chksm=8c411da4bb3694b288625a0baa18d88bdff36a3136f9d0d7fb1d1a43e13ca00dfa053765ac23&amp;cur_album_id=1384528806857539584&amp;scene=189#wechat_redirect">手撸一款简单高效的线程池</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池概要&quot;&gt;&lt;a href=&quot;#线程池概要&quot; class=&quot;headerlink&quot; title=&quot;线程池概要&quot;&gt;&lt;/a&gt;线程池概要&lt;/h1&gt;&lt;p&gt;一个线程池的主要组成部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务队列：存放Provider分配的任务（task），工作线程</summary>
      
    
    
    
    <category term="并行计算" scheme="https://cszhouy.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="线程池" scheme="https://cszhouy.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="C++" scheme="https://cszhouy.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>五子棋AI设计（一）：基于MinMax实现</title>
    <link href="https://cszhouy.github.io/blog/47e2e24c.html"/>
    <id>https://cszhouy.github.io/blog/47e2e24c.html</id>
    <published>2023-04-23T13:45:58.000Z</published>
    <updated>2023-04-23T14:19:58.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="评估函数"><a href="#评估函数" class="headerlink" title="评估函数"></a>评估函数</h1><p>与人类的思维相同，程序在决策每一步棋时应该评估所有落点的优劣，选择最优的一步棋，因此我们需要为程序制定一套评价标准（评估函数）。每当程序执子时，它将依据这个评估函数做出决策。设计评估函数并没有固定的方法，这里采用一种比较简单的方法：<strong>五元组评价</strong>。</p><p>对于每一个落点，它只会影响包含它的五个连续的位置，因此我们将棋盘行、列、斜线方向分成若干个五元组。五元组的个数等于所有五子连珠情况的个数。五元组被表示为一个长度为5的坐标数组，其中坐标为<code>row * BOARD_SIZE + col</code>。</p><p>在一个五元组中，当己方棋子越多且连续，胜率越大，我们为五元组的多种情况做以下规定：</p><ul><li>五元组中有任意个对方棋子，得分为 0</li><li>五元组中没有己方棋子，得分为 0</li><li>五元组中有 1 个己方棋子，得分为 1 </li><li>五元组中有 2 个连续己方棋子，得分为 20 </li><li>五元组中有 3 个连续己方棋子，得分 600 </li><li>五元组中有 4 个连续己方棋子，得分 4000</li><li>五元组中有 5 个连续己方棋子，得分 1000000</li></ul><p>计算单个五元组中棋子<code>chessType</code>的评分如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 6&gt; shape_score&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">600</span>, <span class="number">4000</span>, <span class="number">1000000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Gobang::tuple_evaluate</span><span class="params">(ChessType chessType, <span class="type">const</span> FiveTuple &amp; fiveTuple)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IS_SAME_TYPE</span>(board[<span class="built_in">XPOS</span>(fiveTuple[i])][<span class="built_in">YPOS</span>(fiveTuple[i])], chessType))&#123;</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">IS_SAME_TYPE</span>(board[<span class="built_in">XPOS</span>(fiveTuple[i])][<span class="built_in">YPOS</span>(fiveTuple[i])], <span class="built_in">OPP</span>(chessType)))&#123;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shape_score[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每一个落子进行评价时，有两种思路：</p><ul><li>对落子后的单个落点进行评分。即在该落点落子后，计算包含该落点的所有五元组的评分。</li><li>对落子后的整个棋局进行评分。即在该落点落子后，计算整个棋局所有五元组的评分。</li></ul><p>显然第二种方式更合理，因为它更具有全局意识。另外，在评估棋局时我们要攻防兼顾，因此将全局的评估函数设为己方评分与对方评分之差。 $H$ 表示全局评分值，$S(x, y)$ 表示 $(x, y)$ 处棋盘的评分，即五元组评分之和。</p><script type="math/tex; mode=display">H_{global} = H_{self} - H_{opp} = \sum S_{self}(x, y) - \sum S_{opp}(x, y)</script><p>在计算所有五元组的评分时，我们不应该遍历每一个位置的五元组，因为一个五元组包含五个位置，这样会导致4倍多余的计算。本程序实现的思路是将所有五元组放在一个容器中，而每一个位置仅保存所有包含该位置的五元组的索引（哈希）。在计算评估函数值时，遍历容器中的五元组；检查落子是否形成连珠时，也能方便的搜索落点的五元组，并有利于后续优化。</p><p>标识单个五元组的索引类似于向量表示，将五元组两端的坐标移位拼接成一个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Gobang::fiveTuple_index</span><span class="params">(<span class="type">const</span> FiveTuple&amp; fiveTuple)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fiveTuple[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) + fiveTuple[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="贪心搜索"><a href="#贪心搜索" class="headerlink" title="贪心搜索"></a>贪心搜索</h1><p>设计完评估函数，我们可以实现一个基于贪心搜索的初级版本。其思想是搜索所有空余落点，找到评价函数值最大的落点，在该处落子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Gobang::greedy_select</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; j &lt; BOARD_SIZE; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;BOARD_SIZE; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[i][j] = order * computer;</span><br><span class="line">            <span class="type">int</span> h = <span class="built_in">total_evaluate</span>(computer) - <span class="built_in">total_evaluate</span>(player);</span><br><span class="line">            <span class="keyword">if</span>(h &gt; max)&#123;</span><br><span class="line">                max = h;</span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line">            &#125;</span><br><span class="line">            board[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">POSITION</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法可以计算出下一步所有落点的评估函数值，但在现实对弈中，仅考虑当前一步时远远不够的，有下棋经验的人都会或多或少向后推演几步，因此，我们需要增加它的搜索层数。</p><h1 id="局部搜索"><a href="#局部搜索" class="headerlink" title="局部搜索"></a>局部搜索</h1><p>考虑新算法前，先进行一次必要的剪枝操作。在选择最佳落点时，玩家往往只用考虑已下棋子周围的落点，而非遍历整个棋盘。我们维护一个<code>openlist</code>，用于存储已下棋子周围的位置，下完一步棋，就将其继续扩展。</p><p><code>openlist</code>被定义为<code>std::set&lt;int&gt;</code>，该函数扩展<code>openlist</code>，并返回扩展前的<code>openlist</code>，用于后续的回溯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">Gobang::extend_openlist</span><span class="params">(<span class="type">int</span> xpos, <span class="type">int</span> ypos)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">IN_BOARD</span>(xpos, ypos));</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0</span> != board[xpos][ypos]);</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; oldlist = openlist;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; neighbors = <span class="built_in">neighbor</span>(xpos, ypos, <span class="number">1</span>);  <span class="comment">// (xpos, ypos)周围的空余位置，步长为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos : neighbors)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == board[<span class="built_in">XPOS</span>(pos)][<span class="built_in">YPOS</span>(pos)])&#123;</span><br><span class="line">            openlist.<span class="built_in">insert</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    openlist.<span class="built_in">erase</span>(<span class="built_in">POSITION</span>(xpos, ypos));</span><br><span class="line">    <span class="keyword">return</span> oldlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MinMax算法"><a href="#MinMax算法" class="headerlink" title="MinMax算法"></a>MinMax算法</h1><p>贪心搜索具有一层的搜索深度，如果要搜索多层，需要考虑和模拟对方的落子，即搜索对方可能落点，并依据评估函数进行决策，但在考虑己方和对方的落子时存在区别：</p><ul><li>当己方落子时，总是考虑局面对自己<strong>最有利</strong>的情况，即选择<strong>评估函数值最大</strong>的落点</li><li>当对方落子时，总是考虑局面对自己<strong>最不利</strong>的情况，即选择<strong>评估函数值最小</strong>的落点</li></ul><p>如果把每一个可能的落子情况视为一个树节点，树的根节点为开局（或搜索开始时）棋局，那么当游戏参与者交替行棋，树的每一层节点选择子节点的行为不同：当前层为我方落子时，选择子节点中评估函数值最大的；当前层为对方落子时，选择子节点中评估函数值最小的。这种树称为<strong>博弈树</strong>，也称为Min-Max树。</p><p>以井字棋（“三子棋”）为例，假如评估函数被设置为“X”（我方）胜利为1，“O”（对方）胜利为-1，下面详细展示了一棵三层的博弈树状态。</p><p><img src="https://pic.imgdb.cn/item/64400f2c0d2dde57778828e8.jpg" alt=""></p><p>Max层节点的值取子节点的最大值，Min层节点的值取子节点最小值，叶子节点的值为评估函数值。树搜索过程为DFS，一旦到达搜索深度或者已经出现胜利（或失败）棋局则返回上层，停止搜索。另一个详细的MinMax搜索过程如下图：</p><p><img src="https://pic.imgdb.cn/item/644011310d2dde57778acdf8.jpg" alt=""></p><p>实现MinMax算法后，程序能够做到向下搜索3层，但随着搜索层数的增加以及棋局向后发展，棋局状态数即节点数是呈指数增长的，程序运行时间也会越来越久。</p><h1 id="alpha-beta剪枝"><a href="#alpha-beta剪枝" class="headerlink" title="alpha-beta剪枝"></a>alpha-beta剪枝</h1><p>为了提高搜索效率，MinMax算法总是离不开一种剪枝策略，即 $\alpha-\beta$ 剪枝。仔细观察博弈树，可以发现在搜索过程中我们不需要遍历所有节点，当无法从某条分支上获取更优的值时进行剪枝。</p><p><img src="https://pic.imgdb.cn/item/644016570d2dde57779059c5.jpg" alt=""></p><p>如图，根节点为Max节点，它会选择子节点中的最大值，因此当搜索完左分支后可以确定根节点的值至少为 -13，即下限 $\alpha$ 为 -13。当右子节点搜索完它的左分支后已经获取了一个值-75，由于右子节点为Min节点，它会选择子节点中的最小值，那么右子节点的值小于 -75，即上限 $\beta$ 为 -75。此时右子树已经确定不会被选择，所以不会再去搜索它的右分支。</p><p>$\alpha-\beta$ 剪枝算法有多种形式化表述，这是我认为最详细的一种：</p><blockquote><ul><li>初始根节点 $\alpha = -\infty$ ，$\beta = +\infty$ </li><li>Max层节点 $\alpha = max(\alpha, \text{所有子节点评价值})$ , $\beta$ 等于父节点 $\beta$ </li><li>Min层节点 $\alpha = min(\beta, \text{所有子节点评价值})$ , $\alpha$ 等于父节点 $\alpha$</li><li>当某个节点 $\alpha &gt; \beta$ ，停止搜索该节点的其它子节点</li></ul></blockquote><p>实现 $\alpha-\beta$ 剪枝算法后的MinMax搜索如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinmaxNode</span>&#123;</span><br><span class="line">    ChessType type;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> next_best;</span><br><span class="line">    <span class="built_in">MinmaxNode</span>(ChessType type, <span class="type">int</span> pos): <span class="built_in">type</span>(type), <span class="built_in">pos</span>(pos)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 参数node为父节点 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gobang::minmax_v1</span><span class="params">(<span class="type">int</span> depth, MinmaxNode &amp; node, <span class="type">int</span> alpha, <span class="type">int</span> beta)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth == <span class="number">0</span> || <span class="built_in">check_win</span>(node.type, <span class="built_in">XPOS</span>(node.pos), <span class="built_in">YPOS</span>(node.pos)))&#123;</span><br><span class="line">        node.value = <span class="built_in">total_evaluate</span>(computer) - <span class="built_in">total_evaluate</span>(player);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">list</span><span class="params">(openlist.begin(), openlist.end())</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(node.type == computer)&#123;  <span class="comment">// MIN</span></span><br><span class="line">        node.value = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> pos : list)&#123;</span><br><span class="line">            <span class="built_in">fill_board</span>(<span class="built_in">OPP</span>(node.type), <span class="built_in">XPOS</span>(pos), <span class="built_in">YPOS</span>(pos));</span><br><span class="line">            std::set&lt;<span class="type">int</span>&gt; oldlist = <span class="built_in">extend_openlist</span>(<span class="built_in">XPOS</span>(pos), <span class="built_in">YPOS</span>(pos));</span><br><span class="line">            <span class="function">MinmaxNode <span class="title">snode</span><span class="params">(OPP(node.type), pos)</span></span>;</span><br><span class="line">            <span class="comment">// the next node is MAX</span></span><br><span class="line">            <span class="comment">// for MAX, beta equals parent&#x27;s beta</span></span><br><span class="line">            <span class="built_in">minmax_v1</span>(depth - <span class="number">1</span>, snode, INT_MIN, beta);</span><br><span class="line">            <span class="comment">// traceback</span></span><br><span class="line">            <span class="built_in">unfill_board_back</span>(<span class="built_in">XPOS</span>(pos), <span class="built_in">YPOS</span>(pos));</span><br><span class="line">            openlist = oldlist;</span><br><span class="line">            <span class="keyword">if</span>((node.value &gt; snode.value))&#123;</span><br><span class="line">                node.value = snode.value;</span><br><span class="line">                node.next_best = snode.pos;</span><br><span class="line">            &#125;</span><br><span class="line">            beta = std::<span class="built_in">min</span>(beta, node.value);</span><br><span class="line">            <span class="keyword">if</span>(beta &lt; alpha)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.type == player)&#123;  <span class="comment">// MAX</span></span><br><span class="line">        node.value = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> pos : list)&#123;</span><br><span class="line">            <span class="built_in">fill_board</span>(<span class="built_in">OPP</span>(node.type), <span class="built_in">XPOS</span>(pos), <span class="built_in">YPOS</span>(pos));</span><br><span class="line">            std::set&lt;<span class="type">int</span>&gt; oldlist = <span class="built_in">extend_openlist</span>(<span class="built_in">XPOS</span>(pos), <span class="built_in">YPOS</span>(pos));</span><br><span class="line">            <span class="function">MinmaxNode <span class="title">snode</span><span class="params">(OPP(node.type), pos)</span></span>;</span><br><span class="line">            <span class="comment">// the next node is MIN</span></span><br><span class="line">            <span class="comment">// for MAX, alpha equals parent&#x27;s alpha</span></span><br><span class="line">            <span class="built_in">minmax_v1</span>(depth - <span class="number">1</span>, snode, alpha, INT_MAX);</span><br><span class="line">            <span class="comment">// traceback</span></span><br><span class="line">            <span class="built_in">unfill_board_back</span>(<span class="built_in">XPOS</span>(pos), <span class="built_in">YPOS</span>(pos));</span><br><span class="line">            openlist = oldlist;</span><br><span class="line">            <span class="keyword">if</span>((node.value &lt; snode.value))&#123;</span><br><span class="line">                node.value = snode.value;</span><br><span class="line">                node.next_best = snode.pos;</span><br><span class="line">            &#125;</span><br><span class="line">            alpha = std::<span class="built_in">max</span>(alpha, node.value);</span><br><span class="line">            <span class="keyword">if</span>(alpha &gt; beta)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剪枝后，搜索时间已经大大减少，VS优化代码后，搜索3层所用时间基本在200ms以内。至此，我们已经实现了一个具有一定棋力的五子棋AI，但是和有一定水平的玩家相比，仅搜索3层是远远不够的。后续的内容将继续围绕如何优化搜索以减少搜索时间、提高搜索层数展开。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201301&amp;filename=1012450252.nh">刘瑞. 五子棋人工智能算法设计与实现[D].华南理工大学,2012.</a></li><li><a href="https://dspace.cvut.cz/bitstream/handle/10467/70078/F3-BP-2017-Muzika-Martin-Application%20of%20Game%20Theoretic%20Algorithms.pdf">Application of Game Theoretic Algorithms to Gomoku</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;评估函数&quot;&gt;&lt;a href=&quot;#评估函数&quot; class=&quot;headerlink&quot; title=&quot;评估函数&quot;&gt;&lt;/a&gt;评估函数&lt;/h1&gt;&lt;p&gt;与人类的思维相同，程序在决策每一步棋时应该评估所有落点的优劣，选择最优的一步棋，因此我们需要为程序制定一套评价标准（评估函数</summary>
      
    
    
    
    <category term="五子棋AI" scheme="https://cszhouy.github.io/categories/%E4%BA%94%E5%AD%90%E6%A3%8BAI/"/>
    
    
    <category term="C++" scheme="https://cszhouy.github.io/tags/C/"/>
    
    <category term="人工智能" scheme="https://cszhouy.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>计算机体系结构——流水线</title>
    <link href="https://cszhouy.github.io/blog/5e96f6cc.html"/>
    <id>https://cszhouy.github.io/blog/5e96f6cc.html</id>
    <published>2023-04-20T09:26:29.000Z</published>
    <updated>2023-04-25T09:41:45.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流水线五阶段"><a href="#流水线五阶段" class="headerlink" title="流水线五阶段"></a>流水线五阶段</h1><p>所有的RISC架构都有以下几个关键的特性：</p><ul><li>所有数据操作都是对寄存器中的数据操作，通常会改变整个寄存器（每个寄存器为32位或64位）</li><li>只有载入和存储操作会影响存储器，它们将数据从存储器移到寄存器或从寄存器移到存储器。载入和存储小于一个完整的寄存器的操作通常是有效的</li><li>指令的格式相对固定，所有指令位宽通常相同。在RISC-V中，寄存器说明符rs1、rs2和rd总是固定在同一个位置编码从而简化了控制</li></ul><p>RISC子集中的每条指令都可以在最多5个时钟周期内实现。这五个时钟周期如下（非流水化）：</p><h2 id="取指周期（IF）"><a href="#取指周期（IF）" class="headerlink" title="取指周期（IF）"></a>取指周期（IF）</h2><p>将程序计数器发送到存储器，从存储器提取当前指令。程序计数器+4，将程序计数器更新到下一条顺序指令。其中NPC表示小一条只指令的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IR := Mem[PC]</span><br><span class="line">NPC := PC+4</span><br></pre></td></tr></table></figure><h2 id="指令译码-读寄存器周期（ID）"><a href="#指令译码-读寄存器周期（ID）" class="headerlink" title="指令译码/读寄存器周期（ID）"></a>指令译码/读寄存器周期（ID）</h2><p>对指令进行译码，读取寄存器。其中rs1、rs2表示源寄存器，A、B表示两个临时寄存器。同时对指令中的偏移量进行符号扩展，将扩展后的值与PC相加，计算出可能的目标分支。指令译码与寄存器的读取是并行执行的，得益于固定字段译码技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A := Regs[rs1]</span><br><span class="line">B := Regs[rs2]</span><br><span class="line">Imm := sign-extended immediate field of IR</span><br></pre></td></tr></table></figure><h2 id="执行-有效地址周期（EX）"><a href="#执行-有效地址周期（EX）" class="headerlink" title="执行/有效地址周期（EX）"></a>执行/有效地址周期（EX）</h2><p>ALU对上一周期准备的操作数进行操作，根据指令类型执行三条指令之一。</p><ul><li>存储器引用：ALU将基址存储器和偏移量加到一起，形成有效地址。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALUOutput := A + Imm</span><br></pre></td></tr></table></figure><ul><li>寄存器-寄存器ALU指令：ALU对读自寄存器堆的值执行功能代码指定的操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALUOutput := A func B</span><br></pre></td></tr></table></figure><ul><li>寄存器-立即数ALU指令：ALU对读自寄存器堆的第一个值和符号扩展立即数执行由ALU操作码指定的操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALUOuput :=  A op Imm</span><br></pre></td></tr></table></figure><ul><li>分支指令：ALU将NPC加到Imm的符号扩展立即数，将该立即数左移两位，得到一个字偏移量，以计算分支的地址。这里仅考虑分支的一种形式（相等则跳转）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALUOutput := NPC + (Imm &lt;&lt; 2)</span><br><span class="line">Cond := (A==B)</span><br></pre></td></tr></table></figure><p>在载入-存储操作体系结构中，有效地址与执行周期可以合并到一个时钟周期中，这是因为没有指令需要计算数据地址并对数据执行操作。</p><h2 id="存储器访存周期（MEM）"><a href="#存储器访存周期（MEM）" class="headerlink" title="存储器访存周期（MEM）"></a>存储器访存周期（MEM）</h2><ul><li>载入指令：使用上一周期计算的有效地址从存储器中读取数据。LMD是存储内存数据的临时寄存器。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LMD := MEM[ALUOutput]</span><br></pre></td></tr></table></figure><ul><li>存储指令：使用上一周期计算的有效地址从寄存器堆的第二个寄存器（rs2）读取的数据写入数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MEM[ALUOutput] := B</span><br></pre></td></tr></table></figure><ul><li>分支指令：在分支条件成立时用计算出的分支地址替代PC，作为下一条指令的地址。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (cond) PC := ALUOutput</span><br></pre></td></tr></table></figure><h2 id="写回周期（WB）"><a href="#写回周期（WB）" class="headerlink" title="写回周期（WB）"></a>写回周期（WB）</h2><ul><li>寄存器-寄存器指令和寄存器-立即数指令：将ALU的输出值写回目的寄存器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reg[rd] := ALUOutput</span><br></pre></td></tr></table></figure><ul><li>加载指令：将LMD中的存储值写回到目的寄存器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reg[rd] := LMD</span><br></pre></td></tr></table></figure><p><img src="https://pic2.imgdb.cn/item/644786d20d2dde5777dea08b.jpg" alt=""></p><h1 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h1><h2 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h2><p>在重叠执行模式下，如果硬件无法同时支持指令的所有可能的组合方式，就会出现资源冲突，从而导致结构冒险。结构冒险最常见于某功能单元未能完全流水化的情况，例如仅有一个存储器端口的处理器会在不同指令的IF周期和MEM周期发生冲突。</p><p><strong>结构冒险的解决方法是停顿（stall、流水线气泡）。</strong>例如当IF周期与MEM周期发生冲突时，IF阶段需要停顿。</p><p>停顿会导致流水线性能下降，低于理想性能。</p><script type="math/tex; mode=display">\text{流水化加速比}=\frac{\text{流水线深度}}{1+\text{每条指令的流水线停顿周期}}</script><p>RISC-V采用了一些策略避免了结构冒险。</p><h2 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h2><p>根据流水线中的指令重叠，指令之间存在先后顺序，如果一条指令取决于先前指令的结果，就会出现数据冒险。数据冒险主要有三种：<strong>写后读（RAW）</strong>、<strong>读后写（WAR）</strong>、<strong>写后写（WAW）</strong>。</p><p>例如，对于下面指令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add x1,x2,x3</span><br><span class="line">sub x4,x1,x5</span><br><span class="line">and x6,x1,x7</span><br><span class="line">or  x8,x1,x9</span><br><span class="line">xor x10,x1,x11</span><br></pre></td></tr></table></figure></p><p><code>add</code>后的四条指令都依赖<code>add</code>指令的计算结果，只有当第一条指令WB阶段完成后，后续指令才能在各自的ID阶段读取到正确的值。因此，<code>sub</code>指令至少需要停顿2个周期，<code>and</code>指令至少需要停顿1个周期，<code>or</code>指令无需停顿（当WB写回发生在ID的前半部分，读取寄存器发生在ID的后半部分）。</p><p><img src="https://pic.imgdb.cn/item/643a609e0d2dde577736ed16.jpg" alt=""></p><p>为解决数据冒险，需要使用<strong>转发（forwarding）</strong>技术。该技术是将每一阶段的输出直接发送到前阶段的输入，后续指令无需等到WB阶段结束后才能得到正确值。例如在上述指令中</p><ul><li><code>sub</code>指令的<code>x1</code>作为ALU的一个输入，可以直接从<code>add</code>指令在EX阶段的ALU输出得到，即“ALU输出-ALU输入”转发。</li><li><code>and</code>指令的<code>x1</code>作为ALU的一个输入，可以直接从<code>add</code>指令在MEM阶段的DM输出得到，即“DM输出-ALU输入”转发。</li></ul><p>转发操作不仅限于ALU，可以推广到将结果直接传送给需要它的功能单元。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ld x4,0(x1)</span><br><span class="line">sd x4,12(x1)</span><br></pre></td></tr></table></figure><br><code>sd</code>指令需要<code>ld</code>指令的结果，因此可以将<code>ld</code>指令MEM阶段的DM输出作为<code>sd</code>指令MEM阶段的DM输入。</p><p><strong>并非所有潜在的数据冒险都可以通过转发解决。</strong>有时不得不产生停顿，比如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ld x1,0(x2)</span><br><span class="line">sub x4,x1,x5</span><br><span class="line">and x6,x1,x7</span><br><span class="line">or x8,x1,x9</span><br></pre></td></tr></table></figure></p><p><code>ld</code>指令后的三条指令都依赖于其运算结果，运算结果<code>x1</code>为<code>ld</code>流水线的MEM阶段的DM输出。而对于<code>sub</code>指令，在其流水线的EX阶段就需要<code>x1</code>作为ALU输入，此时<code>ld</code>还未完成MEM周期，必须停顿。<code>and</code>和<code>or</code>则分别需要承受来自于上一个阶段地停顿。</p><p><img src="https://pic.imgdb.cn/item/643a6bdd0d2dde5777447323.jpg" alt=""></p><p>判断是否可以利用转发技术消除停顿的关键是：<strong>当存在数据依赖时，比较结果的产生时间（阶段）与结果的需求时间（阶段），仅当需求在结果产生后转发技术才能有效地消除停顿。</strong></p><h2 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h2><p>分支指令及其它改变程序计数器的指令实现流水化时可能导致控制冒险。分支在五级流水线中通常会导致一个周期的停顿。</p><p><img src="https://pic.imgdb.cn/item/643a72680d2dde57774e4408.jpg" alt=""></p><p>降低流水线分支代价通常有以下几种机制：</p><ol><li>冻结（stall）和冲刷（flush）流水线：当遇到分支等情况时，停止将新指令传入流水线，暂停当前正在执行的指令，并保存流水线状态（冻结）。当确定分支后，如果流水线中的指令不正确，则将未处理完的指令全部丢弃（冲刷）。</li><li>预测未命中：即将每个分支都看作未选中分支，继续提取分支指令后的指令，当分支被选中时，再将已提取的指令转为空操作，重新开始在目标地址提取指令。</li><li>预测命中：即将每个分支都看作选中分支，遇到分支指令后就提取目标地址的指令。这种机制在RISC-V中是可行的，因为分支的目标地址可以在ID阶段计算出来。</li><li>分支延迟。RISC-V不采用该机制，略。</li></ol><p>控制冒险会导致停顿，因此会降低流水线密度。</p><script type="math/tex; mode=display">\text{流水线加速比}=\frac{\text{流水线深度}}{1+\text{分支导致的流水线停顿周期}}=\frac{\text{流水线深度}}{1+\text{分支频率}\times\text{分支代价}}</script><p>上述预测未命中与预测命中的机制是固定的，即每遇到分支指令要么全部预测命中，要么全部预测不命中。有一种更加积极的方式来预测分支，分为以下两类：</p><ul><li>静态分支预测：依赖编译时可用信息来预测分支</li><li>动态分支预测：依赖运行时的信息来预测分支</li></ul><p>动态分支预测使用分支预测缓冲区，使用1个bit记录某一个分支是否被选中。分支预测缓冲区记录当前分支的预测信息（分支选中/分支未选中）。如果预测错误，则将该bit翻转。</p><p>简单的1位预测机制在性能上存在短板：</p><div class="table-container"><table><thead><tr><th>分支</th><th>未选中</th><th>未选中</th><th>未选中</th><th>未选中</th><th>选中</th><th>未选中</th><th>未选中</th></tr></thead><tbody><tr><td>分支预测缓冲区</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>预测正确</td><td>是</td><td>是</td><td>是</td><td>是</td><td>否</td><td>否</td><td>是</td></tr></tbody></table></div><p>当分支总是未选中时，在其被选中时将会出现两次预测错误。因此，经常使用2bit预测机制。</p><p><img src="https://pic.imgdb.cn/item/643a816e0d2dde57775f5c17.jpg" alt=""></p><p>当然并不是位数越高越好，当分支情况如下时，预测位数越高，预测错误越多。</p><div class="table-container"><table><thead><tr><th>分支</th><th>未选中</th><th>未选中</th><th>未选中</th><th>选中</th><th>选中</th><th>选中</th><th>选中</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h1 id="实现流水化"><a href="#实现流水化" class="headerlink" title="实现流水化"></a>实现流水化</h1><p>五级流水线要求每一个时钟周期都是活动状态，数据路径的流水化要求必须将流水线之间的数值放在寄存器中，在每个流水级之间的寄存器称为流水线寄存器或流水线锁存器。<strong>这些流水线寄存器用于从一个流水级向下一个流水级传送数据和控制，直到在某一级流水线中使用后不在需要这些值为止。</strong></p><p><img src="https://pic.imgdb.cn/item/643a838a0d2dde57776146eb.jpg" alt=""></p><p>与非流水化的五阶段相比，流水化的五级流水线有三点改进。</p><h2 id="处理停顿"><a href="#处理停顿" class="headerlink" title="处理停顿"></a>处理停顿</h2><p>在数据冒险中可以看到只有载入指令产生的RAW冒险有将导致停顿，其余的冒险都可以用转发解决。如果存在一个载入指令导致的RAW冲突，当需要该载入数据的指令位于ID级，该载入数据位于EX级，下表描述了所有的情景。</p><div class="table-container"><table><thead><tr><th>ID/EX的操作码字段</th><th>IF/ID的操作码字段</th><th>匹配操作数字段</th></tr></thead><tbody><tr><td>载入</td><td>寄存器-寄存器ALU</td><td>ID/EX.IR[rt] = IF/ID.IR[rs1]</td></tr><tr><td>载入</td><td>寄存器-寄存器ALU</td><td>ID/EX.IR[rt] = IF/ID.IR[rs2]</td></tr><tr><td>载入</td><td>载入、存储、ALU立即数或分支</td><td>ID/EX.IR[rt] = IF/ID.IR[rs1]</td></tr></tbody></table></div><p>IF/ID寄存器保存着ID中指令的状态，它可能用到载入结果，ID/EX寄存器中保存着EX中指令的状态，它是载入指令。一旦检测到冒险，控制单元插入流水线停顿（将ID/EX流水线寄存器中的控制部分改为全0），并防止IF和ID级中的指令继续前进（停止发射）。</p><h2 id="实现转发逻辑"><a href="#实现转发逻辑" class="headerlink" title="实现转发逻辑"></a>实现转发逻辑</h2><p>所有的转发在逻辑上都是从ALU或数据存储器的输出到ALU的输入、数据存储器的输入或零检测单元，因此我们可以对比EX/MEM和MEM/WB级中所包含的IR的目标寄存器和ID/EX和EX/MEM级中所包含的IR的源寄存器，以此来实现转发。</p><p><img src="https://pic2.imgdb.cn/item/6447998c0d2dde5777f6ae12.jpg" alt=""></p><p>在ALU的输入端需要添加多路选择器，实现输入来自寄存器堆或者转发结果的选择。</p><h2 id="处理分支"><a href="#处理分支" class="headerlink" title="处理分支"></a>处理分支</h2><p>通常采用分支预测的方法来解决控制冒险，为了减小预测错误的代价，分支的目标地址应当尽可能先计算出来，因此可以在ID级增加一个加法器，用于计算目标分支。此时分支的目标地址将在ID计算出，而是否命中分支的条件在EX计算出。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/chen0031/Computer-Architecture-A-Quantitative-Approach/blob/master/Book/Computer%20Architecture%20a%20Quantitative%20Approach%206th.pdf">Computer Architecture: A Quantitative Approach 6th Edition</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;流水线五阶段&quot;&gt;&lt;a href=&quot;#流水线五阶段&quot; class=&quot;headerlink&quot; title=&quot;流水线五阶段&quot;&gt;&lt;/a&gt;流水线五阶段&lt;/h1&gt;&lt;p&gt;所有的RISC架构都有以下几个关键的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有数据操作都是对寄存器中的数据操作，</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://cszhouy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://cszhouy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>自制编译器（一）：Flex词法分析</title>
    <link href="https://cszhouy.github.io/blog/14ececb8.html"/>
    <id>https://cszhouy.github.io/blog/14ececb8.html</id>
    <published>2022-10-15T12:27:24.000Z</published>
    <updated>2022-10-17T07:14:51.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flex介绍"><a href="#flex介绍" class="headerlink" title="flex介绍"></a>flex介绍</h1><p>flex是一个词法分析器的生成工具，它可以利用正则表达式来生成匹配相应字符串的C语言代码，其基本语法格式同lex相同。flex通过读取一个有规定格式的源文件，输出一个C语言源程序，即词法分析器。</p><h2 id="flex源文件结构"><a href="#flex源文件结构" class="headerlink" title="flex源文件结构"></a>flex源文件结构</h2><p>flex源文件被<code>%%</code>分成三个部分：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义</span><br><span class="line">%%</span><br><span class="line">规则</span><br><span class="line">%%</span><br><span class="line">用户代码</span><br></pre></td></tr></table></figure></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>定义</strong>部分包含了词法单元名和它的正则规范。一个已有的词法单元可通过<code>&#123;&#125;</code>被其它词法单元的正则规范使用。如果需要引入C语言头文件或者定义C语言全局变量与函数，需要用<code>%&#123; %&#125;</code>括起来后定义在该部分。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> numNum = <span class="number">0</span>;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">WHITE [\t\r\n ]</span><br><span class="line">DIGIT [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">LETTER [a-zA-Z]</span><br><span class="line">NUMBER &#123;DIGIT&#125;*|&#123;DIGIT&#125;*<span class="string">&quot;.&quot;</span>&#123;DIGIT&#125;&#123;DIGIT&#125;*</span><br><span class="line">ID &#123;LETTER&#125;&#123;LETTER&#125;*&#123;DIGIT&#125;*</span><br></pre></td></tr></table></figure><p>需要注意，该部分中定义的词法单元名与相应的正则规范并不是必须的，它类似于C语言中的宏定义<code>#define</code>，仅起到对某个词法单元取别名的作用，flex识别一个词法单元是依据其正则规范。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p><strong>规则</strong>部分用来定义词法分析器分析到一个词法单元时其需要执行的相关动作。该部分包含多个规则条目，每个条目的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern action</span><br></pre></td></tr></table></figure><p>pattern是一个词法单元正则规范，也可以是定义部分中已定义的词法单元名。action是当flex扫描识别到该词法时需要执行的操作，是一个使用<code>&#123;&#125;</code>括起来的C语言程序片段。action中可使用flex内部定义的变量，如<code>yytext</code>与<code>yyleng</code>：</p><ul><li><code>yytext</code>：<code>char*</code>类型，指向当前识别到的词法单元的内容</li><li><code>yyleng</code>：<code>int</code>类型，被赋值为当前识别到的词法单元内容的长度</li></ul><p>每当词法分析器识别到一个新的词法单元，这两个变量均会更新。flex中默认的action为内置<code>ECHO</code>，即输出<code>yytext</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear &#123;numNum = idNum = <span class="number">0</span>;<span class="built_in">printf</span>(<span class="string">&quot;clear!&quot;</span>);&#125;</span><br><span class="line">&#123;NUMBER&#125; &#123;numNum++; <span class="built_in">printf</span>(<span class="string">&quot;NUMBER %s\n&quot;</span>, yytext);&#125;</span><br><span class="line">&#123;ID&#125; &#123;idNum++; <span class="built_in">printf</span>(<span class="string">&quot;ID %s %d\n&quot;</span>, yytext, yyleng);&#125;</span><br><span class="line">&#123;WHITE&#125; ;</span><br></pre></td></tr></table></figure><p>这里定义了三个规则条目：</p><ul><li>当识别到<code>clear</code>时，<code>numNum</code>和<code>idNum</code>被赋值为0，此时pattern为词法单元的正则规范。</li><li>当识别到<code>&#123;NUMBER&#125;</code>时，<code>numNum</code>变量自增1，并输出内容，此时pattern为词法单元名，需要使用<code>&#123;&#125;</code>，下同</li><li>当识别到<code>&#123;ID&#125;</code>时，<code>idNum</code>变量自增1，并输出内容与长度</li><li>当识别到<code>&#123;WHITE&#125;</code>时，跳过</li></ul><p>注意，<strong>flex生成的词法分析器采用<em>最长匹配策略</em>，而当扫描到的某个词法单元匹配多个pattern，且长度相同时，将会优先匹配最先定义的规则条目。</strong>因此，<code>clear</code>规则需要定义在<code>&#123;NUMBER&#125;</code>规则之前。</p><h3 id="用户代码"><a href="#用户代码" class="headerlink" title="用户代码"></a>用户代码</h3><p>该部分用户可添加实现自定义功能的代码，代码将会被复制到flex输出文件<em>lex.yy.c</em>中。通常需要编写<code>main()</code>，作为词法分析器的<code>main()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span> || !(yyin = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>)))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR: Illegal Input File\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    yylex();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d NUMBERs and %d IDs are recorded\n&quot;</span>, numNum, idNum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行参数指定输入文件，最后输出整数/浮点数、标识符的统计数。程序出现的flex定义的变量与函数：</p><ul><li><code>yyin</code> ：<code>FILE*</code>类型，指向flex的输入文件，默认为标准输入；与之对应的是<code>yyout</code>，指向flex输出文件，默认为标准输出</li><li><code>yylex()</code>：flex的扫描程序，它将从<code>yyin</code>指向的文件首部开始扫描，识别每一个词法单元，直到EOF。规则部分中每个词法单元的action将会添加到该函数中，从而实现了执行词法单元对应的操作。action部分可添加<code>return</code>语句，作为<code>yylex()</code>的返回值。如果<code>yylex()</code>因为执行<code>return</code>语句而停止，词法分析器将重新调用<code>yylex()</code>继续扫描。如果要接收<code>yylex()</code>的每一次返回值，需要借助<code>while</code>语句</li></ul><p>词法分析器会调用<code>yywrap()</code>来支持多个文件输入，当函数返回值为0时，表示继续读取<code>yyin</code>所指向的文件；返回值为1时，表示读取完一个文件后结束程序。该函数默认由用户定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">yywrap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没用定义该函数，gcc在编译时会报错<code>undefined reference to &#39;yywrap&#39;</code>。也可以在定义部分添加<code>%option noyywrap</code>，词法分析器将不会调用<code>yywrap()</code>。</p><h2 id="生成词法分析器"><a href="#生成词法分析器" class="headerlink" title="生成词法分析器"></a>生成词法分析器</h2><p>将上述实现计数器功能的flex程序命名为<em>counter.l</em>，在命令行输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex counter.l</span><br></pre></td></tr></table></figure><br>生成<em>lex.yy.c</em>，这就是词法分析器的源文件。使用<code>gcc</code>等编译器编译，最后运行可执行文件，输入文件为<em>input.txt</em></p><p><img src="https://pic1.imgdb.cn/item/634aa9f716f2c2beb19b5ad7.png" style="zoom:80%;" /></p><h1 id="C-Minus词法分析"><a href="#C-Minus词法分析" class="headerlink" title="C Minus词法分析"></a>C Minus词法分析</h1><h2 id="C-Minus惯用的词法"><a href="#C-Minus惯用的词法" class="headerlink" title="C Minus惯用的词法"></a>C Minus惯用的词法</h2><ol><li>下面是语言的关键字：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if int float return void while </span><br></pre></td></tr></table></figure></li><li>下面都是专用符号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / &lt; &lt;= &gt; &gt;= == != = ; , . ( ) [ ] &#123; &#125; /* */</span><br></pre></td></tr></table></figure></li><li>其它标记是<strong><em>ID</em></strong>和<strong><em>NUM</em></strong>，通过下列正则表达式定义：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ID = letter letter*</span><br><span class="line">NUM = digit digit*</span><br><span class="line">letter = a|..|z|A|..|Z</span><br><span class="line">digit = 0|..|9</span><br></pre></td></tr></table></figure></li><li>空格由空白、换行符和制表符组成。空格通常被忽略，除了它必须分开<strong><em>ID</em></strong>和<strong><em>NUM</em></strong>关键字。</li><li>注释通常是C语言符号<code>/*.....*/</code>围起来。注释可以放在任何空包出现的位置上，且可以超过一行。注释不能嵌套。</li></ol><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>C Minus的词法分析要求实现识别C Minus的合法Token，并且其相关信息，包括：</p><ul><li>词法单元类型（int整数）</li><li>第一次出现时所在行</li><li>在一行中的开始位置</li><li>在一行中的结束位置</li></ul><h3 id="Token定义"><a href="#Token定义" class="headerlink" title="Token定义"></a>Token定义</h3><p>使用一个枚举类定义所有词法单元类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">cminus_token_type</span> &#123;</span></span><br><span class="line">    <span class="comment">//运算</span></span><br><span class="line">    ADD = <span class="number">259</span>,</span><br><span class="line">    SUB = <span class="number">260</span>,</span><br><span class="line">    MUL = <span class="number">261</span>,</span><br><span class="line">    DIV = <span class="number">262</span>,</span><br><span class="line">    LT = <span class="number">263</span>,</span><br><span class="line">    LTE = <span class="number">264</span>,</span><br><span class="line">    GT = <span class="number">265</span>,</span><br><span class="line">    GTE = <span class="number">266</span>,</span><br><span class="line">    EQ = <span class="number">267</span>,</span><br><span class="line">    NEQ = <span class="number">268</span>,</span><br><span class="line">    ASSIN = <span class="number">269</span>,</span><br><span class="line">    <span class="comment">//符号</span></span><br><span class="line">    SEMICOLON = <span class="number">270</span>,</span><br><span class="line">    COMMA = <span class="number">271</span>,</span><br><span class="line">    LPARENTHESE = <span class="number">272</span>,</span><br><span class="line">    RPARENTHESE = <span class="number">273</span>,</span><br><span class="line">    LBRACKET = <span class="number">274</span>,</span><br><span class="line">    RBRACKET = <span class="number">275</span>,</span><br><span class="line">    LBRACE = <span class="number">276</span>,</span><br><span class="line">    RBRACE = <span class="number">277</span>,</span><br><span class="line">    <span class="comment">//关键字</span></span><br><span class="line">    ELSE = <span class="number">278</span>,</span><br><span class="line">    IF = <span class="number">279</span>,</span><br><span class="line">    INT = <span class="number">280</span>,</span><br><span class="line">    FLOAT = <span class="number">281</span>,</span><br><span class="line">    RETURN = <span class="number">282</span>,</span><br><span class="line">    VOID = <span class="number">283</span>,</span><br><span class="line">    WHILE = <span class="number">284</span>,</span><br><span class="line">    <span class="comment">//ID和NUM</span></span><br><span class="line">    IDENTIFIER = <span class="number">285</span>,</span><br><span class="line">    INTEGER = <span class="number">286</span>,</span><br><span class="line">    FLOATPOINT = <span class="number">287</span>,</span><br><span class="line">    ARRAY = <span class="number">288</span>,</span><br><span class="line">    LETTER = <span class="number">289</span>,</span><br><span class="line">    <span class="comment">//others</span></span><br><span class="line">    EOL = <span class="number">290</span>,</span><br><span class="line">    COMMENT = <span class="number">291</span>,</span><br><span class="line">    BLANK = <span class="number">292</span>,</span><br><span class="line">    ERROR = <span class="number">258</span></span><br><span class="line">&#125; Token;</span><br></pre></td></tr></table></figure><h3 id="声明和选项设置"><a href="#声明和选项设置" class="headerlink" title="声明和选项设置"></a>声明和选项设置</h3><p>在第一部分声明和选项设置中引用头文件，并定义全局变量：</p><ul><li><code>lines</code>：表示某个词法单元第一次出现时所在行</li><li><code>pos_start</code>：表示词法单元在改行开始位置</li><li><code>pos_end</code>：表示词法单元在该行结束位置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%option noyywrap</span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lexical_analyzer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lines;</span><br><span class="line"><span class="type">int</span> pos_start;</span><br><span class="line"><span class="type">int</span> pos_end;</span><br><span class="line"></span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure><h3 id="词法单元规则"><a href="#词法单元规则" class="headerlink" title="词法单元规则"></a>词法单元规则</h3><p>此部分用于定义C Minus的词法单元的规则，模式采用正则表达式表示，注意当词法单元的pattern中包含特殊字符时，需要使用转义字符<code>\</code>。动作使用C语言描述，确定每个Token在每行的开始位置和结束位置，并且返回该词法单元类型。该返回值为<code>yylex()</code>的返回值。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\+ &#123; pos_start = pos_end;pos_end++;<span class="keyword">return</span> ADD;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>有几个特殊的词法单元需要注意：</p><ul><li><p>End Of Line<br>当词法分析器扫描到换行符时（Windows下为<code>\r\n</code>，Linux下为<code>\n</code>，Mac下为<code>\r</code>），行数<code>lines</code>自增，<code>pos_start</code>与<code>pos_end</code>更新</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\n] &#123; pos_start = <span class="number">1</span>;pos_end = <span class="number">1</span>;lines++;<span class="keyword">return</span> EOL;&#125;</span><br></pre></td></tr></table></figure></li><li><p>注释<br>由于flex生成的词法分析器采用最长匹配策略，且注释<code>/**/</code>包含正则的通配符，正则规范较为复杂。当识别到一个注释时，需要考虑词法单元开始位置和结束位置变化，且多行注释要修改<code>lines</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\/\*([*]*(([^*/])+([/])*)*)*\*\/ &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(yytext); ++i)&#123;</span><br><span class="line">        pos_end++;</span><br><span class="line">        <span class="keyword">if</span>( yytext[i] == <span class="string">&#x27;\n&#x27;</span> )&#123;</span><br><span class="line">            lines += <span class="number">1</span>;pos_end = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> COMMENT;&#125;</span><br></pre></td></tr></table></figure></li><li><p>错误的词法单元<br>当扫描到错误的词法单元，仅返回<code>ERROR</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. &#123;<span class="keyword">return</span> ERROR;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分类处理词法单元"><a href="#分类处理词法单元" class="headerlink" title="分类处理词法单元"></a>分类处理词法单元</h3><p>在同一个输入文件或输入流中，每识别到一个词法单元，将会调用一次<code>yylex()</code>，即词法分析器循环调用<code>yylex()</code>，直到EOF。因此我们要对每一个不同的Token，即<code>yylex()</code>的返回值进行讨论。</p><p>对于空白符、注释、EOL，跳过即可；对于错误单元，输出其错误信息；对于其它词法单元，将其信息保存到存储结构中。存储词法单元时使用的数据结构是链表<code>Token_Stream</code>，接口如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化词法单元流</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Token_Stream_Init</span><span class="params">(Token_Stream* token_stream)</span>;</span><br><span class="line"><span class="comment">// 加入一个新的词法单元，成功返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">append_Token</span><span class="params">(Token_Stream* Token_Stream, <span class="type">char</span>* text, <span class="type">int</span> token, <span class="type">int</span> lines, <span class="type">int</span> pos_start, <span class="type">int</span> pos_end)</span>;</span><br><span class="line"><span class="comment">// 遍历词法单元流</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traversal_Token_Stream</span><span class="params">(<span class="type">const</span> Token_Stream* token_stream)</span>;</span><br></pre></td></tr></table></figure><p>词法单元的分类处理过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(token = yylex())&#123;</span><br><span class="line">        <span class="keyword">switch</span>(token)&#123;</span><br><span class="line">            <span class="keyword">case</span> COMMENT:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BLANK:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EOL:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ERROR:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[ERR]: unable to analysize %s at %d line, from %d to %d\n&quot;</span>, yytext, lines, pos_start, pos_end);</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                append_Token(token_stream, yytext, token, lines, pos_start, pos_end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>完整代码见<a href="https://github.com/cszhouY/CMinus-compiler">仓库</a>。flex生成的词法分析器将会将词法单元的类型、所在行、开始位置与结束位置输出。C语言测试案例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*test.c*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">        a = b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><img src="https://pic1.imgdb.cn/item/634aaa1316f2c2beb19b8eea.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://pan.baidu.com/s/1o6OFfCY?_at_=1665233078383">《编译原理及实践》（美）劳顿 著，冯博琴等 译</a></li><li><a href="https://github.com/kitamado/cminus-compiler">USTC 2019秋 编译原理</a></li><li><a href="https://westes.github.io/flex/manual/">Lexical Analysis With Flex, for Flex 2.6.2</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;flex介绍&quot;&gt;&lt;a href=&quot;#flex介绍&quot; class=&quot;headerlink&quot; title=&quot;flex介绍&quot;&gt;&lt;/a&gt;flex介绍&lt;/h1&gt;&lt;p&gt;flex是一个词法分析器的生成工具，它可以利用正则表达式来生成匹配相应字符串的C语言代码，其基本语法格式同l</summary>
      
    
    
    
    <category term="自制编译器" scheme="https://cszhouy.github.io/categories/%E8%87%AA%E5%88%B6%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    
    <category term="编译原理" scheme="https://cszhouy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="Flex" scheme="https://cszhouy.github.io/tags/Flex/"/>
    
    <category term="词法分析" scheme="https://cszhouy.github.io/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>灰色预测模型</title>
    <link href="https://cszhouy.github.io/blog/f7f4e7b4.html"/>
    <id>https://cszhouy.github.io/blog/f7f4e7b4.html</id>
    <published>2022-09-13T05:00:14.000Z</published>
    <updated>2022-10-17T07:14:51.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h1><p>灰色预测模型使用的不是原始数据序列，而是生成的数据序列。其核心体系是灰色模型，即对原始数据作累加生成（或其他方法生成）得到近似指数规律再进行建模的方法。</p><p>灰色预测模型的优点有：</p><ul><li>仅依靠<strong>少量数据</strong>就能解决预测问题</li><li>利用微分方程挖掘系统的本质，精度高</li><li>运算简便，易于检验</li></ul><p>灰色预测模型有以下局限性：</p><ul><li>只适用于<strong>中短期</strong>的预测</li><li>只适合<strong>指数增长</strong>的预测</li></ul><h1 id="GM-1-1-预测模型"><a href="#GM-1-1-预测模型" class="headerlink" title="GM(1,1)预测模型"></a>GM(1,1)预测模型</h1><p>GM(1,1)预测模型的简要原理是指：首先利用累加技术使数据具备指数规律，然后建立一阶微分方程并对其求解，将所求结果再累减还原，即为灰色预测值，从而对未来进行预测。下文以一个实例介绍该模型的原理与步骤。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>北方某城市1986-1992年道路交通噪声平均声级数据如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">年份</th><th style="text-align:center">1986</th><th style="text-align:center">1987</th><th style="text-align:center">1988</th><th style="text-align:center">1989</th><th style="text-align:center">1990</th><th style="text-align:center">1991</th><th style="text-align:center">1992</th></tr></thead><tbody><tr><td style="text-align:center">平均声级</td><td style="text-align:center">71.1</td><td style="text-align:center">72.4</td><td style="text-align:center">72.4</td><td style="text-align:center">72.1</td><td style="text-align:center">71.4</td><td style="text-align:center">72.0</td><td style="text-align:center">71.6</td></tr></tbody></table></div><p>请预测1993年噪声平均声级数据。</p><h2 id="级比检验"><a href="#级比检验" class="headerlink" title="级比检验"></a>级比检验</h2><p>由于我们研究的对象是每一年的平均声级数据，因此将建立平均声级时间序列如下：</p><script type="math/tex; mode=display">x^{(0)}=(x^{(0)}(1),x^{(0)}(2),...,x^{(0)}(7))\\=(71.1,72.4,72.4,72.1,71.4,72.0,71.6)</script><p>计算序列的级比公式为</p><script type="math/tex; mode=display">\lambda(k)=\frac{x^{(0)}(k-1)}{x^{(0)}(k)},k=2,3,...,n</script><p><strong>当每一个$k$对应的级比值均落在区间$(e^{-\frac{2}{n+1}},e^{\frac{2}{n+2}})$内时，则序列$x^{(0)}$可以作为模型GM(1,1)的数据进行灰色预测。否则，需要对$x^{(0)}$作平移变换，使其落入区间内。</strong>取合适的常数$c$，此时序列的级比为</p><script type="math/tex; mode=display">\lambda(k)=\frac{x^{(0)}(k-1)+c}{x^{(0)}(k)+c} \in (e^{-\frac{2}{n+1}},e^{\frac{2}{n+2}})\quadk=2,3,...,n</script><p>常数$c$的取值需要不断尝试。级比检验代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 级比检验</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preinspect</span>(<span class="params">x</span>):</span><br><span class="line">    n = x.shape[<span class="number">0</span>]</span><br><span class="line">    interval = (np.exp(-<span class="number">2</span>/(n+<span class="number">1</span>)), np.exp(<span class="number">2</span>/(n+<span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span>  interval[<span class="number">0</span>]&lt;x[k-<span class="number">1</span>]/x[k]&lt;interval[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>该例所有数据均通过级比检验。</p><h2 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h2><p>原始数据序列$x^{(0)}$并没有规律，很难预测出未来数据的值和走向，因此我们要挖掘数据内在规律。通常，我们求原始数据序列的<strong>前缀和</strong>。</p><script type="math/tex; mode=display">x^{(1)}(k)=\sum_{i=1}^kx^{(0)}(i)</script><p>由此得到新的时间序列$x^{(1)}=(71.1,143.5,215.9,288,359.4,431.4,503)$。多数情况下，新的数据序列$x^{(1)}$会呈现指数函数曲线走势，该问题给出的数据较为特殊，呈现直线走势。但是我们依旧可以将一段直线视为指数函数曲线的一部分，即可以利用函数$e^{f(t)}+c$拟合$x^{(1)}$的图像。</p><p>拟合函数$e^{f(t)}+c$形式特殊，不难联想到一阶常微分方程的通解。因此，我们可以对$x^{(1)}$建立一阶微分方程，方程的解就是$x^{(1)}$的拟合函数。</p><script type="math/tex; mode=display">\frac{dx^{(1)}}{dt}+ax^{(1)}=b</script><p>由于$x^{(1)}$并非连续函数，而是一个与时间有关的离散的序列，所以$dt=\Delta t=t-(t-1)=1$，$dx^{(1)}=\Delta x^{(1)}=x^{(1)}(t)-x^{(1)}(t-1)=x^{(0)}(t)$。因此，上述一阶微分方程可以转换为以下形式</p><script type="math/tex; mode=display">x^{(0)}(t)=b-ax^{(1)}(t)</script><p>很多有关文献中，为了提高模型的合理性，$x^{(1)}$被修正为均值生成序列$z^{(1)}=(z^{(1)}(0),z^{(1)}(2),…,z^{(1)}(k))$，其中$z^{(1)}(k)=0.5x^{(1)}(k)+0.5x^{(1)}(k-1)$.最后得到灰微分方程为</p><script type="math/tex; mode=display">x^{(0)}(t)=b-az^{(1)}(t)\quad k=2,3,...n</script><p>式中，$x^{(0)}$与$z^{(1)}$均是已知数据，只要求出$a$和$b$，即可带入微分方程求出$x^{(1)}(t)$的解，也就是数据序列的拟合函数。这里使用<strong>最小二乘法</strong>，使拟合值与真实值误差的平方和最小。记$\pmb{u}=[a,b]^T$，$\pmb{Y}=[x^{(0)}(2),x^{(0)}(3),…,x^{(0)}(n)]^T$，$\pmb{B}=\begin{bmatrix}-z^{(1)}(2)&amp;1\\ -z^{(1)}(3)&amp;1\\ …&amp;..\\ -z^{(1)}(n)&amp;1\\\end{bmatrix}$，由最小二乘法，求得使$J(\pmb{u})=(\pmb{Y}-\pmb{Bu})^T(\pmb{Y}-\pmb{Bu})$达到最小值的$\pmb{u}$的估计值为</p><script type="math/tex; mode=display">\pmb{\widehat{u}}=[\widehat{a},\widehat{b}]^T=(\pmb{B^TB})^{-1}\pmb{B^TY}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leastSquare</span>(<span class="params">x, z</span>):</span><br><span class="line">    z = np.expand_dims(z, axis=<span class="number">0</span>)</span><br><span class="line">    Y = np.expand_dims(x[<span class="number">1</span>:].copy(), axis=<span class="number">0</span>).T</span><br><span class="line">    B = np.insert(z[:,<span class="number">1</span>:].T*(-<span class="number">1</span>), <span class="number">1</span>, values=np.ones(z.shape[<span class="number">0</span>]), axis=<span class="number">1</span>)</span><br><span class="line">    u = np.linalg.inv(B.T@B) @ B.T @ Y</span><br><span class="line">    <span class="comment"># return a,b</span></span><br><span class="line">    <span class="keyword">return</span> u[<span class="number">0</span>][<span class="number">0</span>], u[<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><code>x</code>为原始数据序列$x^{(0)}$，<code>z</code>为均值生成序列$z^{(1)}$.最后求得$\widehat{a}=0.00234$，$\widehat{b}=72.7$.</p><p>最后求解微分方程，得到$\widehat{x}^{(1)}$的函数式</p><script type="math/tex; mode=display">{\hat{x}}^{(1)}(k+1)=(x^{(0)}(1)-\frac{\hat{b}}{\hat{a}})e^{-{\hat{a}}k}+\frac{\hat{b}}{\hat{a}}\ ,\ k=1,2,...,n-1,...\\x^{(0)}(k+1)=x^{(1)}(k+1)-x^{(1)}(k)\ ,\ k=1,2,...,n-1,...</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求解微分方程，得到预测值序列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">estimateArray</span>(<span class="params">x, a, b</span>):</span><br><span class="line">    n = x.shape[<span class="number">0</span>]</span><br><span class="line">    xEstSum = np.zeros((n))</span><br><span class="line">    xEst = np.zeros((n))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        xEstSum[k] = (x[<span class="number">0</span>] - b/a) * np.exp(-a*k) + b/a</span><br><span class="line">    xEst[<span class="number">0</span>] = xEstSum[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        xEst[k] = xEstSum[k] - xEstSum[k-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> xEst</span><br></pre></td></tr></table></figure><p><code>xEstSum</code>为预测序列$\widehat{x}^{(1)}$，<code>xEst</code>为预测序列$\widehat{x}^{(0)}$.求解结果如下</p><script type="math/tex; mode=display">\widehat{x}^{(0)}:[71.1\ 72.4\ 72.2\ 72.1\  71.9\ 71.7\ 71.5]\\</script><h2 id="检验预测值"><a href="#检验预测值" class="headerlink" title="检验预测值"></a>检验预测值</h2><p>对于求出来的预测值，需要检验其合理性，有两种检测方法。</p><h3 id="残差检验"><a href="#残差检验" class="headerlink" title="残差检验"></a>残差检验</h3><p>令残差$\varepsilon (k)$为</p><script type="math/tex; mode=display">\varepsilon(k)=\frac{x^{(0)}(k)-\widehat{x}(k)}{x^{(0)}(k)}\ ,\ k=1,2,...,n</script><p>且$\widehat{x}^{(0)}(1)=x^{(0)}(1)$，如果$\varepsilon(k)&lt;0.1$，认为预测模型达到要求；如果$\varepsilon(k)&lt;0.2$，认为预测模型达到较高要求。如果残差不在上述范围，说明灰色预测模型不适合求解该问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 残差检验</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">residualTest</span>(<span class="params">x, xEst</span>):</span><br><span class="line">    n = x.shape[<span class="number">0</span>]</span><br><span class="line">    residual = np.zeros((n))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        residual[k] = (x[k] - xEst[k])/x[k]</span><br><span class="line">    <span class="keyword">return</span> residual</span><br></pre></td></tr></table></figure><h3 id="级比偏差值检验"><a href="#级比偏差值检验" class="headerlink" title="级比偏差值检验"></a>级比偏差值检验</h3><p>由参考数据$x^{(0)}(k-1)$，$x^{(0)}(k)$计算级比$\lambda(k)$，再计算级比偏差</p><script type="math/tex; mode=display">\rho(k) = 1 - (\frac{1-0.5a}{1+0.5a})\lambda(k)</script><p>同理，如果$\rho(k)&lt;0.1$，认为预测模型达到要求；如果$\rho(k)&lt;0.2$，认为预测模型达到较高要求。如果级比偏差不在上述范围，说明灰色预测模型不适合求解该问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 级比偏差值检验</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ratioTest</span>(<span class="params">x, xEst, a</span>):</span><br><span class="line">    n = x.shape[<span class="number">0</span>]</span><br><span class="line">    la = np.zeros((n))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        la[k] = x[k-<span class="number">1</span>]/x[k]</span><br><span class="line">    ratio = np.zeros((n))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        ratio[k] = <span class="number">1</span> - ((<span class="number">1</span>-<span class="number">0.5</span>*a)/(<span class="number">1</span>+<span class="number">0.5</span>*a)) * la[k]</span><br><span class="line">    <span class="keyword">return</span> ratio</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>模型中各种检验指标值的计算结果如下：</p><p><img src="https://pic.imgdb.cn/item/63200e7e16f2c2beb13d0f77.png" alt="GM(1,1)模型检验表" style="zoom:80%;" /></p><p>可以看到除了个别检验指标在接受范围外，大部分指标值都落在接受范围内，说明模型的精度较高，可以进行预报。因此1993年平均噪声平均声级为</p><script type="math/tex; mode=display">\widehat{x}^{(0)}(8)=\widehat{x}^{(1)}(8)-\widehat{x}^{(1)}(7)=71.395</script><p>完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">Copyright(c) 2022 Zhou Yee</span></span><br><span class="line"><span class="string">@Author: Zhou Yee</span></span><br><span class="line"><span class="string">@Date:   2022-09-12 17:08:43</span></span><br><span class="line"><span class="string">@Email:  zhou.yee@foxmail.com</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 灰色预测模型GM(1,1)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 级比检验</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preinspect</span>(<span class="params">x</span>):</span><br><span class="line">    n = x.shape[<span class="number">0</span>]</span><br><span class="line">    interval = (np.exp(-<span class="number">2</span>/(n+<span class="number">1</span>)), np.exp(<span class="number">2</span>/(n+<span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span>  interval[<span class="number">0</span>]&lt;x[k-<span class="number">1</span>]/x[k]&lt;interval[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据平移</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translation</span>(<span class="params">x, c</span>):</span><br><span class="line">    <span class="keyword">return</span> x + c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求前缀和序列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prefixSum</span>(<span class="params">x</span>):</span><br><span class="line">    xSum = x.copy()</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">0</span>]):</span><br><span class="line">        xSum[k] = x[<span class="number">0</span>:k+<span class="number">1</span>].<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> xSum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值生成序列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">averageArray</span>(<span class="params">xSum</span>):</span><br><span class="line">    z = xSum.copy()</span><br><span class="line">    z[<span class="number">0</span>] = xSum[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, xSum.shape[<span class="number">0</span>]):</span><br><span class="line">        z[k] = <span class="number">0.5</span>*xSum[k] + <span class="number">0.5</span>*xSum[k-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小二乘法求解灰微分方程系数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leastSquare</span>(<span class="params">x, z</span>):</span><br><span class="line">    z = np.expand_dims(z, axis=<span class="number">0</span>)</span><br><span class="line">    Y = np.expand_dims(x[<span class="number">1</span>:].copy(), axis=<span class="number">0</span>).T</span><br><span class="line">    B = np.insert(z[:,<span class="number">1</span>:].T*(-<span class="number">1</span>), <span class="number">1</span>, values=np.ones(z.shape[<span class="number">0</span>]), axis=<span class="number">1</span>)</span><br><span class="line">    u = np.linalg.inv(B.T@B) @ B.T @ Y</span><br><span class="line">    <span class="comment"># return a,b</span></span><br><span class="line">    <span class="keyword">return</span> u[<span class="number">0</span>][<span class="number">0</span>], u[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解微分方程，得到预测值序列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">estimateArray</span>(<span class="params">x, a, b</span>):</span><br><span class="line">    n = x.shape[<span class="number">0</span>]</span><br><span class="line">    xEstSum = np.zeros((n))</span><br><span class="line">    xEst = np.zeros((n))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        xEstSum[k] = (x[<span class="number">0</span>] - b/a) * np.exp(-a*k) + b/a</span><br><span class="line">    xEst[<span class="number">0</span>] = xEstSum[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        xEst[k] = xEstSum[k] - xEstSum[k-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> xEst</span><br><span class="line"></span><br><span class="line"><span class="comment"># 残差检验</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">residualTest</span>(<span class="params">x, xEst</span>):</span><br><span class="line">    n = x.shape[<span class="number">0</span>]</span><br><span class="line">    residual = np.zeros((n))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        residual[k] = (x[k] - xEst[k])/x[k]</span><br><span class="line">    <span class="keyword">return</span> residual</span><br><span class="line"><span class="comment"># 级比偏差值检验</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ratioTest</span>(<span class="params">x, xEst, a</span>):</span><br><span class="line">    n = x.shape[<span class="number">0</span>]</span><br><span class="line">    la = np.zeros((n))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        la[k] = x[k-<span class="number">1</span>]/x[k]</span><br><span class="line">    ratio = np.zeros((n))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        ratio[k] = <span class="number">1</span> - ((<span class="number">1</span>-<span class="number">0.5</span>*a)/(<span class="number">1</span>+<span class="number">0.5</span>*a)) * la[k]</span><br><span class="line">    <span class="keyword">return</span> ratio</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x = np.array([<span class="number">71.1</span>,<span class="number">72.4</span>,<span class="number">72.4</span>,<span class="number">72.1</span>,<span class="number">71.4</span>,<span class="number">72.0</span>,<span class="number">71.6</span>])</span><br><span class="line">    <span class="keyword">if</span> preinspect(x):</span><br><span class="line">        xSum = prefixSum(x)</span><br><span class="line">        z = averageArray(xSum)</span><br><span class="line">        <span class="comment"># print(xSum, z)</span></span><br><span class="line">        <span class="comment"># print(np.expand_dims(z, axis=0))</span></span><br><span class="line">        a, b = leastSquare(x, z)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a:&#123;&#125;\nb:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, b))</span><br><span class="line">        xEst = estimateArray(x, a, b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;预测序列：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(xEst))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;残差检验：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(residualTest(x, xEst)))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;级比偏差值检验：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(ratioTest(x, xEst, a)))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;1993年预测值：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            ((x[<span class="number">0</span>] - b/a) * np.exp(-a*<span class="number">7</span>) + b/a) - </span><br><span class="line">            ((x[<span class="number">0</span>] - b/a) * np.exp(-a*<span class="number">6</span>) + b/a)</span><br><span class="line">            ))</span><br></pre></td></tr></table></figure><br>输出结果如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a:0.0023437864785236795</span><br><span class="line">b:72.65726960367881</span><br><span class="line">预测序列：[71.1        72.40574144 72.23623656 72.0671285  71.89841633 71.73009912</span><br><span class="line"> 71.56217595]</span><br><span class="line">残差检验：[ 0.00000000e+00 -7.93016634e-05  2.26192594e-03  4.55915376e-04</span><br><span class="line"> -6.98062087e-03  3.74862332e-03  5.28268865e-04]</span><br><span class="line">级比偏差值检验：[ 0.          0.02025481  0.00234104 -0.0018101  -0.00743993  0.01065487</span><br><span class="line"> -0.00323247]</span><br><span class="line">1993年预测值：71.39464589292038</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://maipdf.cn/pdf/d98289466065@pdf">《数学建模算法与应用 》- 司守奎,孙玺菁</a></li><li><a href="https://www.bilibili.com/video/BV1Zy4y1G73E?spm_id_from=333.337.search-card.all.click&amp;vd_source=0616a823e8776dfee4be063c94cf43e5">【数模赛前突击】灰色预测模型(数学建模零基础入门）- 哔哩哔哩_bilibili</a></li><li><a href="https://numpy.org/doc/">NumPy Documentation</a></li><li><a href="https://d.wanfangdata.com.cn/periodical/ChlQZXJpb2RpY2FsQ0hJTmV3UzIwMjIwOTAxEhFuamxnZHh4YjIwMjAwNTAxMBoINjFqbXZteHY%3D">GM(1,1)灰色预测模型的改进与应用 (wanfangdata.com.cn)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模型简介&quot;&gt;&lt;a href=&quot;#模型简介&quot; class=&quot;headerlink&quot; title=&quot;模型简介&quot;&gt;&lt;/a&gt;模型简介&lt;/h1&gt;&lt;p&gt;灰色预测模型使用的不是原始数据序列，而是生成的数据序列。其核心体系是灰色模型，即对原始数据作累加生成（或其他方法生成）得到近</summary>
      
    
    
    
    <category term="数学建模" scheme="https://cszhouy.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="python" scheme="https://cszhouy.github.io/tags/python/"/>
    
    <category term="数学建模" scheme="https://cszhouy.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="预测方法" scheme="https://cszhouy.github.io/tags/%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线性规划</title>
    <link href="https://cszhouy.github.io/blog/5434385.html"/>
    <id>https://cszhouy.github.io/blog/5434385.html</id>
    <published>2022-09-08T13:06:58.000Z</published>
    <updated>2022-10-17T07:14:51.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性规划简介"><a href="#线性规划简介" class="headerlink" title="线性规划简介"></a>线性规划简介</h1><p>简单来说线性规划（LP）是指在给出一系列约束条件后求解目标函数的极值问题，该类题型在中学数学中常见，这里不再赘述。一个简单的例子:</p><script type="math/tex; mode=display">\max \ f(x)=2x_1 + 3x_2 - 5x3\\s.t\begin{cases}x1 + 3x_2 + x_3 < 12\\2x1 - 5x_2 + x_3 \geq 10\\x_1 + x_2 + x_3 = 7\\x_1,x_2,x_3\leq 0\end{cases}</script><p>$x_1$、$x_2$、$x_3$称为<strong>决策变量</strong>，$f(x)$称为<strong>目标函数</strong>，$s.t.$称为<strong>约束条件</strong>，这是线性规划问题的三个关键因素。在数学建模中，我们需要在具体问题中抽象出这三个关键因素，并分析它们的属性，步骤如下：</p><ul><li>找到决策变量。判断它们是连续的还是离散的。</li><li>写出目标函数。这通常是问题所在，如最大利润，最小成本。目标函数的自变量为决策变量。</li><li>分析约束条件。约束条件指的是对单个决策变量的约束和对多个决策变量的关系进行约束。</li></ul><h1 id="PuLP库求解过程"><a href="#PuLP库求解过程" class="headerlink" title="PuLP库求解过程"></a>PuLP库求解过程</h1><p>python中的Pulp求解以上问题。以上述问题为例，详细介绍一下利用pulp库求解线性规划问题的详细步骤：</p><h3 id="定义规划问题"><a href="#定义规划问题" class="headerlink" title="定义规划问题"></a>定义规划问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LpProb = pulp.LpProblem(name = <span class="string">&#x27;LpProb&#x27;</span>, sense = pulp.LpMaximize)</span><br></pre></td></tr></table></figure><p><code>pulp.LpProblem()</code>有两个参数：</p><ul><li><code>name</code>：该问题的名字。</li><li><code>sense</code>：指定待解决的问题的类型。<code>pulp.LpMaximise</code>为求目标函数的最大值，<code>pulp.LpMinimize</code>为求目标函数的最小值。</li></ul><h3 id="定义决策变量"><a href="#定义决策变量" class="headerlink" title="定义决策变量"></a>定义决策变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x1 = pulp.LpVariable(<span class="string">&#x27;x1&#x27;</span>, lowBound = <span class="number">0</span>, upBound = <span class="number">7</span>, cat = <span class="string">&#x27;Continuous&#x27;</span>)</span><br><span class="line">x2 = pulp.LpVariable(<span class="string">&#x27;x2&#x27;</span>, lowBound = <span class="number">0</span>, upBound = <span class="number">7</span>, cat = <span class="string">&#x27;Continuous&#x27;</span>)</span><br><span class="line">x3 = pulp.LpVariable(<span class="string">&#x27;x3&#x27;</span>, lowBound = <span class="number">0</span>, upBound = <span class="number">7</span>, cat = <span class="string">&#x27;Continuous&#x27;</span>)</span><br></pre></td></tr></table></figure><p>利用<code>pulp.LpVariable()</code>函数创建问题的决策变量。它有五个参数：</p><ul><li><code>name</code>：变量名，在<code>.lp</code>输出文件中将被用到</li><li><code>lowB</code>ound：变量的下限，默认为<code>none</code>，代表负无穷</li><li><code>upBound</code>：变量的上限，默认为<code>none</code>，代表正无穷</li><li><code>cat</code>：设定决策变量的类型，默认为<code>&#39;Continuous&#39;</code>，表示变量是连续的。另外还有<code>&#39;Interger&#39;</code>表示变量是离散的，此时该变量的取值只能为整数；<code>&#39;Binary&#39;</code>表示这是一个二值变量，变量只能为$0/1$</li><li><code>e</code>：指明该决策变量是否在目标函数和约束条件中存在，这里暂时不需要设置该参数</li></ul><p>因此，本题我们定义了三个决策变量$x_1$、$x_2$、$x_3$，它们下限均为$0$，上限均为$7$，且均为连续型变量。</p><h3 id="定义目标函数"><a href="#定义目标函数" class="headerlink" title="定义目标函数"></a>定义目标函数</h3><p>目标函数就是f(x)，添加目标函数的格式为：<strong>问题变量 += 目标函数表达式</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LpProb += <span class="number">2</span>*x1 + <span class="number">3</span>*x2 - <span class="number">5</span>*x3</span><br></pre></td></tr></table></figure><h3 id="定义约束条件"><a href="#定义约束条件" class="headerlink" title="定义约束条件"></a>定义约束条件</h3><p>定义约束条件的格式与定义目标函数的格式类似，但是约束条件式均为等式或不等式：<strong>问题变量 += 约束条件式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LpProb += <span class="number">2</span>*x1 - <span class="number">5</span>*x2 + x3 &gt;= <span class="number">10</span></span><br><span class="line">LpProb += x1 + <span class="number">3</span>*x2 + x3 &lt;= <span class="number">12</span></span><br><span class="line">LpProb += x1 + x2 + x3 == <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LpProb.solve()</span><br></pre></td></tr></table></figure><p><code>solve()</code>参数可以指定PuLP进行求解时使用的求解器，默认为CBC。也可以用其它求解器，如<code>solve(CPLEX())</code></p><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>仅仅调用<code>solve()</code>函数求解还不够，我们还要知道该问题是否有解，最后的结果是多少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;status:&quot;</span>, pulp.LpStatus[LpProb.status])</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> LpProb.variables():</span><br><span class="line">    <span class="built_in">print</span>(v.name, <span class="string">&quot;=&quot;</span>, v.varValue)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;F(x) = &#x27;</span>, pulp.value(LpProb.objective))</span><br></pre></td></tr></table></figure><p>首先请求解决方案的状态，可以是“Not Solved（未解决）”, “Infeasible（不可行）”, “Unbounded（无界）”, “Undefined（未定义）” 和 “Optimal（最优解）”。<strong><code>LpStatus</code>是一个字典类型</strong>。</p><p>其次需要将每个决策变量的值都打印出来，<code>variables()</code>将返回一个列表，遍历打印每一个变量名与变量值。</p><p>最后打印目标函数的最优值。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>综上，利用PuLP求解一般的线性规划问题步骤总结如下：</p><ol><li>使用<code>pulp.LpProblem()</code>创建问题实例</li><li>使用<code>pulp.LpVariable()</code>定义决策变量</li><li><code>LpProb += 表达式</code>设置目标函数</li><li><code>LpProb += 关系式</code>设置约束条件</li><li>调用<code>solve()</code>求解</li><li>输出求解状态、变量取值、目标函数值</li></ol><p>上述问题完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入import库</span></span><br><span class="line"><span class="keyword">import</span> pulp</span><br><span class="line"><span class="comment"># 定义一个规划问题</span></span><br><span class="line">LpProb = pulp.LpProblem(<span class="string">&quot;LPProbDemo1&quot;</span>, sense = pulp.LpMaximize)</span><br><span class="line"><span class="comment"># 定义决策变量</span></span><br><span class="line">x1 = pulp.LpVariable(<span class="string">&#x27;x1&#x27;</span>, lowBound = <span class="number">0</span>, upBound = <span class="number">7</span>, cat = <span class="string">&#x27;Continuous&#x27;</span>)</span><br><span class="line">x2 = pulp.LpVariable(<span class="string">&#x27;x2&#x27;</span>, lowBound = <span class="number">0</span>, upBound = <span class="number">7</span>, cat = <span class="string">&#x27;Continuous&#x27;</span>)</span><br><span class="line">x3 = pulp.LpVariable(<span class="string">&#x27;x3&#x27;</span>, lowBound = <span class="number">0</span>, upBound = <span class="number">7</span>, cat = <span class="string">&#x27;Continuous&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加目标函数</span></span><br><span class="line">LpProb += <span class="number">2</span>*x1 + <span class="number">3</span>*x2 - <span class="number">5</span>*x3</span><br><span class="line"><span class="comment"># 添加约束函数</span></span><br><span class="line">LpProb += <span class="number">2</span>*x1 - <span class="number">5</span>*x2 + x3 &gt;= <span class="number">10</span></span><br><span class="line">LpProb += x1 + <span class="number">3</span>*x2 + x3 &lt;= <span class="number">12</span></span><br><span class="line">LpProb += x1 + x2 + x3 == <span class="number">7</span></span><br><span class="line"><span class="comment"># 求解</span></span><br><span class="line">LpProb.solve()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;status:&quot;</span>, pulp.LpStatus[LpProb.status])</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> LpProb.variables():</span><br><span class="line">    <span class="built_in">print</span>(v.name, <span class="string">&quot;=&quot;</span>, v.varValue)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;F(x) = &#x27;</span>, pulp.value(LpProb.objective))</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">status: Optimal</span><br><span class="line">x1 = 6.4285714</span><br><span class="line">x2 = 0.57142857</span><br><span class="line">x3 = 0.0</span><br><span class="line">F(x) =  14.57142851</span><br></pre></td></tr></table></figure><h1 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h1><p>以上介绍了PuLP求解线性规划问题的基本方法，下面介绍几个应用案例。</p><h2 id="混合问题"><a href="#混合问题" class="headerlink" title="混合问题"></a>混合问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><em>Uncle Ben’s</em>希望尽可能便宜地生产他们的猫粮产品，同时确保它们符合罐头上显示的营养分析要求。因此，他们希望改变每种成分（主要成分是鸡肉，牛肉，羊肉，大米，小麦和凝胶）的数量，同时仍然符合他们的营养标准。鸡肉，牛肉和羊肉的成本分别为0.013美元，0.008美元和0.010美元，而大米，小麦和凝胶的成本分别为0.002美元，0.005美元和0.001美元。<strong>（所有费用均为每克。）</strong></p><p>每种成分将组成最终产品中蛋白质，脂肪，纤维和盐的总重量。每克成分的贡献（以克为单位）如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:center">东西</th><th style="text-align:center">蛋白</th><th style="text-align:center">脂肪</th><th style="text-align:center">纤维</th><th style="text-align:center">盐</th></tr></thead><tbody><tr><td style="text-align:center">鸡</td><td style="text-align:center">0.100</td><td style="text-align:center">0.080</td><td style="text-align:center">0.001</td><td style="text-align:center">0.002</td></tr><tr><td style="text-align:center">牛肉</td><td style="text-align:center">0.200</td><td style="text-align:center">0.100</td><td style="text-align:center">0.005</td><td style="text-align:center">0.005</td></tr><tr><td style="text-align:center">羊肉</td><td style="text-align:center">0.150</td><td style="text-align:center">0.110</td><td style="text-align:center">0.003</td><td style="text-align:center">0.007</td></tr><tr><td style="text-align:center">米饭</td><td style="text-align:center">0.000</td><td style="text-align:center">0.010</td><td style="text-align:center">0.100</td><td style="text-align:center">0.002</td></tr><tr><td style="text-align:center">麦麸</td><td style="text-align:center">0.040</td><td style="text-align:center">0.010</td><td style="text-align:center">0.150</td><td style="text-align:center">0.008</td></tr><tr><td style="text-align:center">凝胶</td><td style="text-align:center">0.000</td><td style="text-align:center">0.000</td><td style="text-align:center">0.000</td><td style="text-align:center">0.000</td></tr></tbody></table></div><p>为了满足营养分析要求，我们需要每100克至少含有8克蛋白质，6克脂肪，但不超过2克纤维和0.4克盐，请问满足营养要求的最小成本开销是多少？</p><h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>首先要从问题中分析出决策变量、目标函数和约束条件。</p><p>设鸡肉、牛肉、羊肉、米饭、麦麸和凝胶的质量分别为$x_1$、$x_2$、$x_3$、$x_4$、$x_5$、$x_6$克，那么目标函数和约束条件如下：</p><script type="math/tex; mode=display">\min \ f(x) = 0.013x_1 + 0.008x_2 + 0.010x_3 + 0.002x_4 + 0.005x_5 + 0.001x_6\\s.t.\begin{cases}x_1 + x_2 + x_3 + x_4 + x_5 + x_6=100\\0.100x_1 + 0.200x_2 + 0.150x_3 + 0.040x_5 \geq 8\\0.080x_1 + 0.100x_2 + 0.110x_3 + 0.010x_4 + 0.010x_5 \geq 6\\0.001x_1 + 0.005x_2 + 0.003x_3 + 0.100x_4 + 0.150x_5 \leq 2\\0.002x_1 + 0.005x_2 + 0.007x_3 + 0.002x_4 + 0.008x_5 \leq 0.4\\\end{cases}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pulp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 定义问题</span></span><br><span class="line">blendLp = LpProblem(<span class="string">&#x27;混合问题&#x27;</span>, LpMinimize)</span><br><span class="line"><span class="comment"># 定义约束变量</span></span><br><span class="line">x1 = LpVariable(<span class="string">&#x27;x1&#x27;</span>, <span class="number">0</span>, <span class="literal">None</span>, LpContinuous)</span><br><span class="line">x2 = LpVariable(<span class="string">&#x27;x2&#x27;</span>, <span class="number">0</span>, <span class="literal">None</span>, LpContinuous)</span><br><span class="line">x3 = LpVariable(<span class="string">&#x27;x3&#x27;</span>, <span class="number">0</span>, <span class="literal">None</span>, LpContinuous)</span><br><span class="line">x4 = LpVariable(<span class="string">&#x27;x4&#x27;</span>, <span class="number">0</span>, <span class="literal">None</span>, LpContinuous)</span><br><span class="line">x5 = LpVariable(<span class="string">&#x27;x5&#x27;</span>, <span class="number">0</span>, <span class="literal">None</span>, LpContinuous)</span><br><span class="line">x6 = LpVariable(<span class="string">&#x27;x6&#x27;</span>, <span class="number">0</span>, <span class="literal">None</span>, LpContinuous)</span><br><span class="line"><span class="comment"># 设置目标函数</span></span><br><span class="line">blendLp += <span class="number">0.013</span>*x1 + <span class="number">0.008</span>*x2 + <span class="number">0.01</span>*x3 + <span class="number">0.002</span>*x4 + <span class="number">0.005</span>*x5 + <span class="number">0.001</span>*x6</span><br><span class="line"><span class="comment"># 设置约束条件</span></span><br><span class="line">blendLp += x1 + x2 + x3 + x4 + x5 + x6 == <span class="number">100</span></span><br><span class="line">blendLp += <span class="number">0.100</span>*x1 + <span class="number">0.200</span>*x2 + <span class="number">0.150</span>*x3 + <span class="number">0.040</span>*x5 &gt;= <span class="number">8</span></span><br><span class="line">blendLp += <span class="number">0.080</span>*x1 + <span class="number">0.100</span>*x2 + <span class="number">0.110</span>*x3 + <span class="number">0.010</span>*x4 + <span class="number">0.010</span>*x5 &gt;= <span class="number">6</span></span><br><span class="line">blendLp += <span class="number">0.001</span>*x1 + <span class="number">0.005</span>*x2 + <span class="number">0.003</span>*x3 + <span class="number">0.100</span>*x4 + <span class="number">0.150</span>*x5 &lt;= <span class="number">2</span></span><br><span class="line">blendLp += <span class="number">0.002</span>*x1 + <span class="number">0.005</span>*x2 + <span class="number">0.007</span>*x3 + <span class="number">0.002</span>*x4 + <span class="number">0.008</span>*x5 &lt;=<span class="number">0.4</span></span><br><span class="line"><span class="comment"># 求解</span></span><br><span class="line">blendLp.solve()</span><br><span class="line"><span class="comment"># 打印求解结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;status: &#x27;</span>, LpStatus[blendLp.status])</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> blendLp.variables():</span><br><span class="line">    <span class="built_in">print</span>(v.name, <span class="string">&quot;=&quot;</span>, v.varValue)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;min = &#x27;</span>, value(blendLp.objective))</span><br></pre></td></tr></table></figure><p>当决策变量与约束条件较多时，使用字典更规范，也更易于修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Ingerdient = [<span class="string">&#x27;chicken&#x27;</span>, <span class="string">&#x27;beef&#x27;</span>, <span class="string">&#x27;mutton&#x27;</span>, <span class="string">&#x27;rice&#x27;</span>, <span class="string">&#x27;wheat&#x27;</span>, <span class="string">&#x27;gel&#x27;</span>]</span><br><span class="line">    cost = &#123;</span><br><span class="line">    <span class="string">&#x27;chicken&#x27;</span> : <span class="number">0.013</span>,</span><br><span class="line">    <span class="string">&#x27;beef&#x27;</span> : <span class="number">0.008</span>,</span><br><span class="line">    <span class="string">&#x27;mutton&#x27;</span> : <span class="number">0.01</span>,</span><br><span class="line">    <span class="string">&#x27;rice&#x27;</span> : <span class="number">0.002</span>,</span><br><span class="line">    <span class="string">&#x27;wheat&#x27;</span> : <span class="number">0.04</span>,</span><br><span class="line">    <span class="string">&#x27;gel&#x27;</span> : <span class="number">0.001</span></span><br><span class="line">    &#125;</span><br><span class="line">    protein = &#123;</span><br><span class="line">    <span class="string">&#x27;chicken&#x27;</span> : <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">&#x27;beef&#x27;</span> : <span class="number">0.2</span>,</span><br><span class="line">    <span class="string">&#x27;mutton&#x27;</span> : <span class="number">0.15</span>,</span><br><span class="line">    <span class="string">&#x27;rice&#x27;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;wheat&#x27;</span> : <span class="number">0.04</span>,</span><br><span class="line">    <span class="string">&#x27;gel&#x27;</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    fat = &#123;</span><br><span class="line">    <span class="string">&#x27;chicken&#x27;</span> : <span class="number">0.08</span>,</span><br><span class="line">    <span class="string">&#x27;beef&#x27;</span> : <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">&#x27;mutton&#x27;</span> : <span class="number">0.11</span>,</span><br><span class="line">    <span class="string">&#x27;rice&#x27;</span> : <span class="number">0.01</span>,</span><br><span class="line">    <span class="string">&#x27;wheat&#x27;</span> : <span class="number">0.01</span>,</span><br><span class="line">    <span class="string">&#x27;gel&#x27;</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    fibre = &#123;</span><br><span class="line">    <span class="string">&#x27;chicken&#x27;</span> : <span class="number">0.001</span>,</span><br><span class="line">    <span class="string">&#x27;beef&#x27;</span> : <span class="number">0.005</span>,</span><br><span class="line">    <span class="string">&#x27;mutton&#x27;</span> : <span class="number">0.003</span>,</span><br><span class="line">    <span class="string">&#x27;rice&#x27;</span> : <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">&#x27;wheat&#x27;</span> : <span class="number">0.15</span>,</span><br><span class="line">    <span class="string">&#x27;gel&#x27;</span> : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    salt = &#123;</span><br><span class="line">    <span class="string">&#x27;chicken&#x27;</span> : <span class="number">0.002</span>,</span><br><span class="line">    <span class="string">&#x27;beef&#x27;</span> : <span class="number">0.005</span>,</span><br><span class="line">    <span class="string">&#x27;mutton&#x27;</span> : <span class="number">0.007</span>,</span><br><span class="line">    <span class="string">&#x27;rice&#x27;</span> : <span class="number">0.002</span>,</span><br><span class="line">    <span class="string">&#x27;wheat&#x27;</span> : <span class="number">0.008</span>,</span><br><span class="line">    <span class="string">&#x27;gel&#x27;</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    blendLp = LpProblem(<span class="string">&quot;混合问题&quot;</span>, LpMinimize)</span><br><span class="line">    varsLp = LpVariable.<span class="built_in">dict</span>(<span class="string">&#x27;Ingerdient&#x27;</span>, Ingerdient, <span class="number">0</span>)</span><br><span class="line">    blendLp += (lpSum([cost[i] * varsLp[i] <span class="keyword">for</span> i <span class="keyword">in</span> Ingerdient]), </span><br><span class="line">        <span class="string">&quot;total cost of Ingerdient per can&quot;</span>)</span><br><span class="line">    blendLp += (lpSum([varsLp[i] <span class="keyword">for</span> i <span class="keyword">in</span> Ingerdient]) == <span class="number">100</span>, <span class="string">&quot;PercentagesSum&quot;</span>)</span><br><span class="line">    blendLp += (lpSum([varsLp[i] * protein[i] <span class="keyword">for</span> i <span class="keyword">in</span> Ingerdient]) &gt;= <span class="number">8</span>, <span class="string">&quot;ProteinRequirement&quot;</span>)</span><br><span class="line">    blendLp += (lpSum([varsLp[i] * fat[i] <span class="keyword">for</span> i <span class="keyword">in</span> Ingerdient]) &gt;= <span class="number">6</span>, <span class="string">&quot;FatRequirement&quot;</span>)</span><br><span class="line">    blendLp += (lpSum([varsLp[i] * fibre[i] <span class="keyword">for</span> i <span class="keyword">in</span> Ingerdient]) &lt;= <span class="number">2</span>, <span class="string">&quot;FibreRequirement&quot;</span>)</span><br><span class="line">    blendLp += (lpSum([varsLp[i] * salt[i] <span class="keyword">for</span> i <span class="keyword">in</span> Ingerdient]) &lt;=<span class="number">4</span>, <span class="string">&quot;saltRequirement&quot;</span> )</span><br><span class="line">    blendLp.solve()</span><br></pre></td></tr></table></figure><h2 id="0-1规划"><a href="#0-1规划" class="headerlink" title="0-1规划"></a>0-1规划</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>公司有 5 个项目被列入投资计划，各项目的投资额和预期投资收益如下表所示（万元）：</p><div class="table-container"><table><thead><tr><th>项目</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>投资额</td><td>210</td><td>300</td><td>100</td><td>130</td><td>260</td></tr><tr><td>投资收益</td><td>150</td><td>210</td><td>60</td><td>80</td><td>180</td></tr></tbody></table></div><p>公司只有 600万元资金可用于投资，综合考虑各方面因素，需要保证：</p><p>（1）项目 A、B、C 中必须且只能有一项被选中；<br>（2）项目 C、D 中最多只能选中一项；<br>（3）选择项目 E 的前提是项目 A被选中。</p><p>如何在上述条件下，进行投资决策，使收益最大。</p><h3 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h3><p>定义决策变量：定义五个二值变量$x_1$、$x_2$、$x_3$、$x_4$、$x_5$，表示每个项目是否被选中，被选中则为1，未被选中则为0.</p><p>目标函数和约束条件如下：</p><script type="math/tex; mode=display">\max \ F=150x_1 + 210x_2 + 60x_3 + 80x_4 + 180x_5\\s.t.\begin{cases}210x_1 + 300x_2 + 100x_3 + 130x_4 + 260x_5 \leq600\\x_1 + x_2 + x_3 = 1\\x_3 + x_4 \leq1\\x_5 \leq x_1\end{cases}</script><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prob = LpProblem(<span class="string">&quot;0-1规划&quot;</span>, LpMaximize)</span><br><span class="line">x1 = LpVariable(<span class="string">&#x27;A&#x27;</span>, cat = <span class="string">&#x27;Binary&#x27;</span>)</span><br><span class="line">x2 = LpVariable(<span class="string">&#x27;B&#x27;</span>, cat = <span class="string">&#x27;Binary&#x27;</span>)</span><br><span class="line">x3 = LpVariable(<span class="string">&#x27;C&#x27;</span>, cat = <span class="string">&#x27;Binary&#x27;</span>)</span><br><span class="line">x4 = LpVariable(<span class="string">&#x27;D&#x27;</span>, cat = <span class="string">&#x27;Binary&#x27;</span>)</span><br><span class="line">x5 = LpVariable(<span class="string">&#x27;E&#x27;</span>, cat = <span class="string">&#x27;Binary&#x27;</span>)</span><br><span class="line">prob += <span class="number">150</span>*x1 + <span class="number">210</span>*x2 + <span class="number">60</span>*x3 + <span class="number">80</span>*x4 + <span class="number">180</span>*x5</span><br><span class="line">prob += <span class="number">210</span>*x1 + <span class="number">300</span>*x2 + <span class="number">100</span>*x3 + <span class="number">130</span>*x4 + <span class="number">260</span>*x5 &lt;= <span class="number">600</span></span><br><span class="line">prob += x1 + x2 + x3 == <span class="number">1</span></span><br><span class="line">prob += x3 + x4 &lt;= <span class="number">1</span></span><br><span class="line">prob += x1 - x5 &lt;= <span class="number">0</span></span><br><span class="line">prob.solve()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;status: &quot;</span>, LpStatus[prob.status])</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> prob.variables():</span><br><span class="line">    <span class="built_in">print</span>(v.name, <span class="string">&quot;=&quot;</span>, v.varValue)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;max = &quot;</span>, value(prob.objective))</span><br></pre></td></tr></table></figure><p>得到如下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status:  Optimal</span><br><span class="line">A = 1.0</span><br><span class="line">B = 0.0</span><br><span class="line">C = 0.0</span><br><span class="line">D = 1.0</span><br><span class="line">E = 1.0</span><br><span class="line">max =  410.0</span><br></pre></td></tr></table></figure><h2 id="数独问题"><a href="#数独问题" class="headerlink" title="数独问题"></a>数独问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>数独的规则为：</p><ul><li>在9个单独的3x3盒子中的任何一个中，必须找到每个数字1到9。</li><li>在 9x9 网格的任何列中，必须找到每个数字 1 到 9。</li><li>在 9x9 网格的任何一行中，必须找到每个数字 1 到 9。</li></ul><div align=center><img src="https://pic.imgdb.cn/item/631a135b16f2c2beb1ad6ca9.png"></div><h3 id="解题过程-2"><a href="#解题过程-2" class="headerlink" title="解题过程"></a>解题过程</h3><p>问题的关键在于寻找决策变量。</p><p>最容易想到的方法是每一个单元设置一个变量，代表要填入的数，这样需要设置81个决策变量。但是这样无法设置约束条件，即同一行同一列和同一$3x3$的盒子中不能有相同值。</p><p>这里，我们创建 729 个单独的二进制 （0-1） 决策变量，表示9x9网格中每个单元的9种取值情况。每种取值有两种情况，即是（1）和不是（0）。我们用一个三元组表示决策变量，格式为$(vals, rows, cols)$，即第$rows$行第$cols$列值是否为$val$。例如$(5, 7, 3)$表示第7行第3列是否为5，如果是，该变量取值为$1$，否则取值为$0$。</p><p>另外注意，<strong>该题不需要设置目标函数，因为它并不是求最优解问题，只要满足约束条件，即为一个可行解。</strong></p><p>理解了决策变量的含意后，就很容易设置约束条件了。</p><ul><li>同一个单元中只能有一个值</li><li>同一个值在一行中有且只有一个</li><li>同一个值在一列中有且只有一个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pulp <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 总共有9行9列，每一个单元中可以选择的值有9个</span></span><br><span class="line">vals = rows = cols = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">#定义一个问题，不需要设置目标函数，也不需要有第二个参数</span></span><br><span class="line">prob = LpProblem(<span class="string">&quot;数独问题&quot;</span>)</span><br><span class="line"><span class="comment"># 设置决策变量</span></span><br><span class="line">choices = LpVariable.dicts(<span class="string">&quot;choice&quot;</span>, (vals, rows, cols), cat = <span class="string">&#x27;Binary&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置约束条件</span></span><br><span class="line"><span class="comment"># 同一个单元只有一个值</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> rows:</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cols:</span><br><span class="line">        prob += lpSum([choices[v][r][c] <span class="keyword">for</span> v <span class="keyword">in</span> vals]) == <span class="number">1</span></span><br><span class="line"><span class="comment"># 同一个值在一行中有且只有一个</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> vals:</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> rows:</span><br><span class="line">        prob += lpSum([choices[v][r][c] <span class="keyword">for</span> c <span class="keyword">in</span> cols]) == <span class="number">1</span></span><br><span class="line"><span class="comment"># 同一个值在一列中有些只有一个</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> vals:</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cols:</span><br><span class="line">        prob += lpSum([choices[v][r][c] <span class="keyword">for</span> r <span class="keyword">in</span> rows]) == <span class="number">1</span></span><br><span class="line"><span class="comment"># 将已知的值填入</span></span><br><span class="line">input_data = [</span><br><span class="line">    (<span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>),</span><br><span class="line">    (<span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">    (<span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">7</span>, <span class="number">7</span>),</span><br><span class="line">    (<span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>),</span><br><span class="line">    (<span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>),</span><br><span class="line">    (<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> (v, r, c) <span class="keyword">in</span> input_data:</span><br><span class="line">    prob += choices[v][r][c] == <span class="number">1</span></span><br><span class="line"><span class="comment"># 解决问题</span></span><br><span class="line">prob.solve()</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;status: &quot;</span>, LpStatus[prob.status])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> rows:</span><br><span class="line">    <span class="keyword">if</span> r <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;+-------+-------+-------+&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cols:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> vals:</span><br><span class="line">            <span class="keyword">if</span>(value(choices[v][r][c])) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>]:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;| &quot;</span>, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">str</span>(v) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> c == <span class="number">9</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;|&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+-------+-------+-------+&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果如下，答案不止一种。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">status:  Optimal</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">| 5 3 9 | 6 7 2 | 8 1 4 |</span><br><span class="line">| 6 7 3 | 1 9 5 | 4 2 8 |</span><br><span class="line">| 3 9 8 | 7 4 1 | 5 6 2 |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">| 8 5 2 | 9 6 7 | 1 4 3 |</span><br><span class="line">| 4 2 6 | 8 5 3 | 7 9 1 |</span><br><span class="line">| 7 1 4 | 3 2 8 | 9 5 6 |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">| 9 6 1 | 5 3 4 | 2 8 7 |</span><br><span class="line">| 2 8 7 | 4 1 9 | 6 3 5 |</span><br><span class="line">| 1 4 5 | 2 8 6 | 3 7 9 |</span><br><span class="line">+-------+-------+-------+</span><br></pre></td></tr></table></figure><h2 id="运输问题"><a href="#运输问题" class="headerlink" title="运输问题"></a>运输问题</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>一家啤酒厂有两个仓库，从中将啤酒分发给五个酒吧。在每周开始时，每个酒吧都会向啤酒厂总部发送订单，订购很多箱啤酒，然后从相应的仓库发送到酒吧。啤酒厂希望有一个交互式计算机程序可以告诉他们哪个仓库应该供应哪个酒吧，以最大限度地降低整个运营的成本。例如，假设在给定的一周开始时，啤酒厂在仓库 A 有 1000 个箱子，在仓库 B 有 4000 个箱子，而条形图分别需要 500、900、1800、200 和 700 个箱子。哪个仓库应该供应哪个酒吧？</p><div align=center><img src="https://pic.imgdb.cn/item/631a13e316f2c2beb1ae1250.jpg"></div><p>我们假设每个箱子都有固定的运输成本，成本如下（元/箱）</p><div class="table-container"><table><thead><tr><th style="text-align:center">From Warehouse to Bar</th><th style="text-align:center">A</th><th style="text-align:center">B</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">5</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">1</td><td style="text-align:center">3</td></tr></tbody></table></div><h3 id="解题过程-3"><a href="#解题过程-3" class="headerlink" title="解题过程"></a>解题过程</h3><p>决策变量为每一个仓库送到每一个酒吧的箱子个数，$A_i$表示从仓库A运输到酒吧$i$的箱子个数，$B_i$表示从仓库B运输到酒吧$i$的箱子个数，$Wa_i$表示从仓库A运输到酒吧$i$的成本，$Wb_i$表示从仓库B运输到酒吧$i$的成本，$D_i$表示酒吧$i$的需求量</p><script type="math/tex; mode=display">\min \ F = \sum_{i=1}^5 (A_iWa_i+B_iWb_i) \\s.t:\begin{cases} \sum_{i = 1}^5 A_i \leq 1000 \\\sum_{i = 1}^5 B_i \leq 4000\\A_i + B_i \geq D_i &{i\in\{1, 2, 3, 4, 5\}}\\\end{cases}</script><p>该题利用<strong>“分析决策变量，设置目标函数，设置约束条件”</strong>的步骤做，由于变量较多，利用字典来表示变量的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pulp <span class="keyword">import</span> *</span><br><span class="line">warehouse = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">supply = &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">4000</span>&#125;</span><br><span class="line">bars = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>]</span><br><span class="line">demand = &#123;</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="number">900</span>,</span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>: <span class="number">1800</span>,</span><br><span class="line">    <span class="string">&#x27;4&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">&#x27;5&#x27;</span>: <span class="number">700</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 运输成本</span></span><br><span class="line">cost = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">routes = [(w, b) <span class="keyword">for</span> w <span class="keyword">in</span> warehouse <span class="keyword">for</span> b <span class="keyword">in</span> bars]</span><br><span class="line"><span class="comment"># 定义问题</span></span><br><span class="line">prob = LpProblem(<span class="string">&#x27;运输问题&#x27;</span>, LpMinimize)</span><br><span class="line"><span class="comment"># 定义决策变量</span></span><br><span class="line"><span class="built_in">vars</span> = LpVariable.dicts(<span class="string">&quot;路线&quot;</span>, (warehouse, bars), <span class="number">0</span>, <span class="literal">None</span>, LpInteger)</span><br><span class="line"><span class="comment"># 设置目标函数</span></span><br><span class="line">prob += (lpSum([<span class="built_in">vars</span>[w][b] * cost[w][<span class="built_in">int</span>(b)-<span class="number">1</span>] <span class="keyword">for</span> (w, b) <span class="keyword">in</span> routes]),</span><br><span class="line">    <span class="string">&#x27;运输成本&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置约束条件</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> warehouse:</span><br><span class="line">    prob += (lpSum([<span class="built_in">vars</span>[w][b] <span class="keyword">for</span> b <span class="keyword">in</span> bars]) &lt;= supply[w],</span><br><span class="line">        <span class="string">&quot;运出仓库%s&quot;</span> % w)</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> bars:</span><br><span class="line">    prob += (lpSum([<span class="built_in">vars</span>[w][b] <span class="keyword">for</span> w <span class="keyword">in</span> warehouse]) &gt;= demand[b], </span><br><span class="line">        <span class="string">&quot;运进酒吧%s&quot;</span> % b)</span><br><span class="line"><span class="comment"># 求解问题</span></span><br><span class="line">prob.solve()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;status: &#x27;</span>, LpStatus[prob.status])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> prob.variables():</span><br><span class="line">    <span class="built_in">print</span>(v.name, v.varValue)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;min = &#x27;</span>, value(prob.objective))</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">status:  Optimal</span><br><span class="line">路线_A_1 300.0</span><br><span class="line">路线_A_2 0.0</span><br><span class="line">路线_A_3 0.0</span><br><span class="line">路线_A_4 0.0</span><br><span class="line">路线_A_5 700.0</span><br><span class="line">路线_B_1 200.0</span><br><span class="line">路线_B_2 900.0</span><br><span class="line">路线_B_3 1800.0</span><br><span class="line">路线_B_4 200.0</span><br><span class="line">路线_B_5 0.0</span><br><span class="line">min =  8600.0</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://youcans.blog.csdn.net/article/details/117388930">Python小白的数学建模课 - CSDN博客</a></li><li><a href="https://coin-or.github.io/pulp/">Optimization with PuLP — PuLP 2.6.0 documentation (coin-or.github.io)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性规划简介&quot;&gt;&lt;a href=&quot;#线性规划简介&quot; class=&quot;headerlink&quot; title=&quot;线性规划简介&quot;&gt;&lt;/a&gt;线性规划简介&lt;/h1&gt;&lt;p&gt;简单来说线性规划（LP）是指在给出一系列约束条件后求解目标函数的极值问题，该类题型在中学数学中常见，这里不再</summary>
      
    
    
    
    <category term="数学建模" scheme="https://cszhouy.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="python" scheme="https://cszhouy.github.io/tags/python/"/>
    
    <category term="数学建模" scheme="https://cszhouy.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="线性规划" scheme="https://cszhouy.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法</title>
    <link href="https://cszhouy.github.io/blog/9cfaa3ca.html"/>
    <id>https://cszhouy.github.io/blog/9cfaa3ca.html</id>
    <published>2022-09-05T13:25:42.000Z</published>
    <updated>2022-10-17T07:14:51.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>遗传算法（GA）是模拟生物在自然环境中的遗传和进化过程而形成的一种自适应全局优化概率搜索算法。该算法基于达尔文的“适者生存，不适者淘汰”的自然选择学说，将问题的可行解集合视为种群，依据<strong>适应度</strong>挑选出种群中的优势个体进行<strong>“复制”</strong>、<strong>“交叉”</strong>与<strong>“突变”</strong>，从而淘汰掉劣势个体，使得整个种群向最优的方向发展。</p><p>遗传算法将每个自变量视为一个基因，一个可行解为一个个体，所有可行解的集合为种群，目标函数值得优化程度为种群对环境得适应度。因此，可行解向最优解靠近的过程就可以被视为一个种群向适应环境方向进化的过程。在迭代中，优势解被保留，劣势解被舍弃，即为“优生劣汰”。同时，我们模仿生物遗传过程中基因与染色体的交叉、变异操作，对可行解进行扰动，即可到达全局搜索和局部搜索的目的。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>生物学介绍，ATCGU等嘌呤或嘧啶的不同排列为基因编码。在遗传算法中，我们也需要将每个自变量进行编码。总的来说，编码方法可以分为三大类：二进制编码方法、浮点数编码方法、符号编码方法。本文主要介绍二进制编码方法与浮点数编码方法。</p><h3 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h3><p>二进制编码方法使用二进制符号0和1对变量进行编码。对于取值范围为$[X_{min}, X_{max}]$的变量$x$，我们用长度为$l$的二进制串来表示该变量，则它能产生$2^l$中不同的编码。其中二进制数$0$映射变量下限$X_{min}$，二进制数$2^l-1$映射变量上限$X_{max}$。也就是说，我们用二进制串将区间平分为$2^l-1$份，第$i$段小区间内的值均用二进制数$2^i$表示。此时二进制编码精度为：</p><script type="math/tex; mode=display">\delta = \frac{X_{max}-X_{min}}{2^l-1}</script><p>假设一个个体的二进制编码为$X_b$，则对应的<strong>解码公式</strong>为</p><script type="math/tex; mode=display">x=X_{min}+X_o\dot{\frac{X_{max}-X_{min}}{2^l-1}}</script><p>其中$x$为该个体的实际值，$X_o$为二进制数$X_b$的十进制值。当个体的基因数大于1即问题包含多元变量时，我们通常将每个变量的二进制编码依次整体排列。</p><p>二进制编码的优点是编码解码操作简单易行，且交叉、变异等遗传操作便于实现，但其精度较低，局部搜索能力较差。当要求高精度时，不得不增加二进制串的长度，这将导致算法的搜索空间扩大。</p><h3 id="格雷码编码"><a href="#格雷码编码" class="headerlink" title="格雷码编码"></a>格雷码编码</h3><p>格雷码是普通二进制编码的变形，其表示精度与二进制编码相同。连续两个整数所对应的格雷码编码值之间仅仅只有一位编码值不同，其余位完全相同。假设有一个二进制编码为$B=b_mb_{m-1}…b_2b_1$，其与格雷码$G=g_mg_{m-1}…g_2g_1$之间的转换关系如下</p><script type="math/tex; mode=display">\begin{cases}g_m=b_m\\g_i=b_{i+1}\oplus b_i & i=m-1,m-2,...,2,1\\\end{cases}</script><p>在突变操作时，我们需要改变一个或少数基因座的值。如果使用标准二进制编码，编码串对应的参数值将可能发生大幅改变，这样导致算法的局部搜索能力下降；如果使用格雷码编码，编码串对应的参数值仅向其邻域发生微小的改变，这样提高了算法对连续函数局部空间的搜索能力。</p><h3 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h3><p>浮点数编码也叫作真值编码，个体的每个基因值用某一范围内的一个浮点数表示，通常使用决策变量的真实值，此时基因长度为1（一个浮点数），个体的编码长度等于其决策变量的个数。例如一个优化问题含有三个变量$x_1$、$x_2$和$x_3$，对应的浮点编码串为</p><script type="math/tex; mode=display">X:\quad |1.05|4.90|0.97|</script><p>这表示此时$x_1$、$x_2$和$x_3$的取值分别为$1.05$、$4.90$和$0.97$。</p><p><strong>浮点数编码方法更适合在遗传算法中表示范围较大的数，更适合于精度要求较高的遗传算法，更适合于处理复杂的约束条件。</strong></p><h2 id="个体适应度评价"><a href="#个体适应度评价" class="headerlink" title="个体适应度评价"></a>个体适应度评价</h2><p>在遗传算法中，以个体适应度的大小来确定该个体被遗传到下一代群体中个概率。个体适应度越大，该个体遗传到下一代的概率越大；个体适应度越小，该个体遗传到下一代的概率越小。<strong>对于求无约束的目标函数最大值的问题，如果函数值总取正值，通常设定个体适应度$F(X)$等于目标函数值；对于求无约束的目标函数最大值问题，我们对目标函数增加一个负号，将其转换为求最大值的优化问题。</strong></p><p>由于概率是非负值，需要确保个体适应度总为非负值。因此对于最大值优化问题，个体适应度做如下转换</p><script type="math/tex; mode=display">F(X)=\begin{cases}f(X)+C_{min} & f(X)+C_{min}>0\\0 & f(X)+C_{min} \leq 0\end{cases}</script><p><strong>其中$C_{min}$可以取一个充分小值，也可以取进化到当前代为止出现的最小目标函数值。</strong></p><p>对于最小值优化问题，个体适应度做如下转换</p><script type="math/tex; mode=display">F(X)=\begin{cases}C_{max}-f(X) & f(X)<C_{max}\\0 & f(x) \geq C_{max}\end{cases}</script><p><strong>其中$C_{max}$可以取一个充分大值，也可以取进化到当前代为止出现的最大目标函数值</strong></p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>选择是指从当前代群体中选择出一些优良个体，并将其复制到下一代群体，而未被选择的个体将被淘汰。通常我们采取比例选择方法，也叫作<strong>轮盘赌</strong>。我们将个体的适应度在种群总适应度所占比例视为个体被选择的概率，个体适应度占比越大，被选择的概率也就越大。因此，当种群规模为$N$时，个体$i$被选中的概率为</p><script type="math/tex; mode=display">P(X_i)=\frac{F(X_i)}{\sum_{i=1}^NF(x_i)}</script><p>通常，我们在种群集合依概率$P(X)$有放回地抽取$N$个个体，组成新的种群集合，以确保不改变种群规模。</p><h2 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h2><p>交叉是指将某两个或多个个体的基因片段进行交换，以产生出新个体，提高全局搜索能力。</p><h3 id="单点交叉与多点交叉"><a href="#单点交叉与多点交叉" class="headerlink" title="单点交叉与多点交叉"></a>单点交叉与多点交叉</h3><p>单点交叉是最简单的交叉方法，即在个体编码串中随机设置一个交叉点，在该点相互交换两个配对个体的部分染色体。</p><script type="math/tex; mode=display">\begin{matrix}A: & 100110|{011}\\B: & 010011|{101}\end{matrix}\quad=>\quad\begin{matrix}A: & 100110|{101}\\B: & 010011|{011}\end{matrix}</script><p>单点交叉对个体编码结构的破坏最小，当个体适应度较高时，单点交叉降低个体适应度的可能性最小。另外，还有双点交叉与多点交叉等多种交叉方式。其中双点交叉表示在个体编码串中设置两个交叉点，将两个交叉点中间的编码串进行交换，如下：</p><script type="math/tex; mode=display">\begin{matrix}A: & 10|{0110}|011\\B: & 01|{0011}|101\end{matrix}\quad=>\quad\begin{matrix}A: & 10|{0011}|011\\B: & 01|{0110}|101\end{matrix}</script><p>顾名思义，多点交叉指设两个以上的交叉点。但是在交叉过程中一般不推荐使用多点交叉方式，因为它可能破坏一些好的模式，使适应度高的个体很难保存下来，从而影响遗传算法的性能。</p><p><strong>需要注意，进行交叉的个体是随机配对的，交叉点的选取也是随机的，已配对的个体依概率发生交叉。</strong></p><h3 id="算术交叉"><a href="#算术交叉" class="headerlink" title="算术交叉"></a>算术交叉</h3><p>算数交叉是指由两个个体的线性组合而产生出两个新的个体，<strong>算数交叉操作的对象一般是浮点数编码的个体。</strong>假设在两个个体$X_A^t$、$X_B^t$之间进行交叉算数交叉，则交叉后产生的两个新个体为</p><script type="math/tex; mode=display">\begin{cases}X_A^{t+1}=\alpha X_B^{t} + (1-\alpha) X_A^t\\X_B^{t+1}=\alpha X_A^{t} + (1-\alpha) X_B^t\\\end{cases}</script><p>当$\alpha$是一个常数时，此时交叉运算称为均匀算术交叉运算；当$\alpha$是一个由进化代数所决定的变量时，此时交叉运算称为非均匀算数交叉。</p><h2 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h2><p>变异是指，在较小概率内，将个体染色体编码串中的某些基因用其它等位基因替代。变异操作能够改善算法的局部搜索能力，并且维持种群的多样性，防止出现早熟现象，使程序陷入局部最优解的可能性降低。</p><h3 id="基本位变异"><a href="#基本位变异" class="headerlink" title="基本位变异"></a>基本位变异</h3><p>二进制编码最常用的变异方法为基本位变异，其中基本位变异包括单点变异于多点变异，即随机选取编码串上一个或多个基因座发生突变。对于二进制编码，变异操作就是将个体在变异点上的基因座上的值取反。</p><script type="math/tex; mode=display">单点变异:\quad 1001{1}0011\ =>\ 1001{0}0011\\多点变异:\quad 10{0}1{1}00{1}1\ =>\ 10{1}1{0}00{0}1\\</script><p>基本位变异基因座位置是随机的。</p><h3 id="非均匀变异"><a href="#非均匀变异" class="headerlink" title="非均匀变异"></a>非均匀变异</h3><p>基本位变异并不适合浮点数编码的串，对于浮点数编码的个体，可以用变量取值范围$[X_{min}, X_{max}]$内的某个值替换原基因值。当取值范围中每一个值被选中的概率是均匀的，称为<strong>均匀变异</strong>。均匀变异在遗传算法运行初期能使搜索点在整个搜索空间内自由移动，有利于增加种群多样性；但是它不适合对重点区域进行搜索，在算法运行后期将会影响性能。</p><p>非均匀变异的具体操作过程与均匀变异相似，但它重点搜索原个体附近的微小区域。若变异点$x_k$处基因值得取值范围为$[X^k_{min}, X^k_{max}]$，则新的基因值$x_k’$为</p><script type="math/tex; mode=display">x_k'=\begin{cases}x_k+\Delta(t,X_{max}^k-x_k) & rand()\mod 2=0\\x_k+\Delta(t,x_k-X_{max}^k) & rand()\mod 2=1\\\end{cases}</script><p>其中，$\Delta(t,y)$表示在$[0,y]$范围内符合非均匀分布的一个随机数，并且随着进化代数$t$的增加，$\delta(t,y)$趋近于$0$的概率也逐渐增加。以下是一种$\Delta(t,y)$的定义方式</p><script type="math/tex; mode=display">\Delta (t,y)=y\cdot (1-r^{(\frac{1-t}{T})b})</script><p>非均匀变异使得算法在初期进行均匀随机搜索，而在后期进行局部搜索。随着算法的进行，非均匀编译使得最优解的搜索过程更加集中在某一更有希望的重点区域中。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><p>遗传算的步骤如下：</p><ol><li><strong>初始化种群</strong>。设置种群参数，包括种群规模、基因长度、染色体长度、迭代次数等</li><li><strong>编码</strong>。确定合适的编码方式，建立由个体基因型$X$到个体表现型$x$的映射关系</li><li><strong>评价个体适应度</strong>。确定由目标函数$f(x)$到个体适应度$F(x)$的转换规则</li><li><strong>选择</strong>。依据个体适应度，以一定规则挑选出个体适应高的个体复制到下一代</li><li><strong>交叉</strong>。对种群中的个体之间进行随机配对，并使用合适的交叉方法依概率交换个体的基因片段</li><li><strong>突变</strong>。以较小概率改变个体的一个或多个基因。</li><li><strong>判断是否满足迭代终止条件</strong>。通常为是否达到最大迭代次数$G_{max}$，若满足则输出种群最优个体；若不满足回到第4步</li></ol><p><img src="https://pic.imgdb.cn/item/631607f616f2c2beb1c199ff.png" style="zoom: 80%;" /></p><h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><p><em>Rosenbrock</em>香蕉函数定义如下：</p><script type="math/tex; mode=display">f(x_1,x_2)=100(x_1^2+x_2)^2+(1-x_1)^2\\~\\s.t.\ -2.048\leq x_1,x_2\leq 2.048\\</script><div align=center><img src="https://pic.imgdb.cn/item/631607d216f2c2beb1c1747f.png"></div><p>设置种群规模为$100$，单个基因长度为$10$，交叉率为$0.6$，突变率为$0.01$，进化代数为$100$，利用二进制编码方式对变量进行编码，采用双点交叉、基本位变异方法，遗传算法程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GA</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nVar, xMin, xMax, geneLen, popSize = <span class="number">100</span>, crosRate = <span class="number">0.6</span>, mutRate = <span class="number">0.01</span>, generation = <span class="number">100</span></span>):</span><br><span class="line">        self.nVar = nVar                            <span class="comment"># 变量个数</span></span><br><span class="line">        self.xMin = np.array(xMin, dtype = <span class="built_in">float</span>)   <span class="comment"># 自变量下限</span></span><br><span class="line">        self.xMax = np.array(xMax, dtype = <span class="built_in">float</span>)   <span class="comment"># 自变量上限</span></span><br><span class="line">        self.popSize = popSize                      <span class="comment"># 种群规模</span></span><br><span class="line">        self.geneLen = geneLen                      <span class="comment"># 基因长度</span></span><br><span class="line">        self.chromLen = nVar * geneLen              <span class="comment"># 染色体长度  </span></span><br><span class="line">        self.crosRate = crosRate                    <span class="comment"># 交叉率</span></span><br><span class="line">        self.mutRate = mutRate                      <span class="comment"># 突变率</span></span><br><span class="line">        self.generation = generation                <span class="comment"># 迭代次数</span></span><br><span class="line">        <span class="comment"># 初始化第一代种群，二进制编码</span></span><br><span class="line">        self.pop = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=(self.popSize, self.chromLen))</span><br><span class="line">    <span class="comment"># 解码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">translate</span>(<span class="params">self</span>):</span><br><span class="line">        popPerform = np.zeros((self.popSize, self.nVar), dtype=<span class="built_in">float</span>)</span><br><span class="line">        <span class="comment"># 转换成十进制</span></span><br><span class="line">        tmp = np.logspace(self.geneLen - <span class="number">1</span>, <span class="number">0</span>, self.geneLen, base=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.popSize):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.nVar):</span><br><span class="line">                popPerform[i][j] = np.dot(self.pop[i][j*self.geneLen:(j+<span class="number">1</span>)*self.geneLen], tmp)</span><br><span class="line">        <span class="comment"># 利用解码公式转换</span></span><br><span class="line">        popPerform = self.xMin + popPerform * (self.xMax - self.xMin)/(<span class="number">2</span>**self.geneLen - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> popPerform</span><br><span class="line">    <span class="comment"># 适应度，由于该目标函数值总为正值，因此直接将目标函数作为个体适应度评价标准</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fitness</span>(<span class="params">self, X</span>):</span><br><span class="line">        x1, x2 = X[<span class="number">0</span>], X[<span class="number">1</span>]</span><br><span class="line">        fx = <span class="number">100</span> * (x1**<span class="number">2</span> - x2)**<span class="number">2</span> + (<span class="number">1</span>-x1)**<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> fx</span><br><span class="line">    <span class="comment"># 选择</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 计算每个个体的适应度</span></span><br><span class="line">        popFit = np.array([self.fitness(self.translate()[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.popSize)])</span><br><span class="line">        <span class="comment"># 轮盘赌选择下一代</span></span><br><span class="line">        idx = np.random.choice(np.arange(self.popSize), size=self.popSize, replace=<span class="literal">True</span>, p=(popFit)/(popFit.<span class="built_in">sum</span>()) )</span><br><span class="line">        self.pop = self.pop[idx]</span><br><span class="line">    <span class="comment"># 交叉</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">crossover</span>(<span class="params">self</span>):</span><br><span class="line">        idx = np.arange(self.popSize)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.popSize//<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 从种群中随机抽取一对个体进行交叉</span></span><br><span class="line">            idx_i = np.random.choice(idx.shape[<span class="number">0</span>], size = <span class="number">2</span>, replace=<span class="literal">False</span>)</span><br><span class="line">            couple = idx[idx_i]</span><br><span class="line">            idx = np.delete(idx, idx_i)</span><br><span class="line">            <span class="comment"># 以一定概率发生交叉</span></span><br><span class="line">            <span class="keyword">if</span> rd.uniform(<span class="number">0</span>,<span class="number">1</span>) &lt; self.crosRate:</span><br><span class="line">                <span class="comment"># 随机抽取一段基于片段</span></span><br><span class="line">                l = rd.randint(<span class="number">0</span>, self.popSize-<span class="number">1</span>)</span><br><span class="line">                r = rd.randint(l, self.popSize)</span><br><span class="line">                self.pop[couple, l:r] = self.pop[couple[::-<span class="number">1</span>], l:r]</span><br><span class="line">    <span class="comment"># 突变</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mutation</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.popSize):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.chromLen):</span><br><span class="line">                <span class="comment"># 以一定概率突变</span></span><br><span class="line">                <span class="keyword">if</span> rd.uniform(<span class="number">0</span>, <span class="number">1</span>) &lt; self.mutRate:</span><br><span class="line">                    self.pop[i][j] = <span class="keyword">not</span> self.pop[i][j]</span><br><span class="line">    <span class="comment"># 迭代</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> gen <span class="keyword">in</span> <span class="built_in">range</span>(self.generation):</span><br><span class="line">            self.select()</span><br><span class="line">            self.crossover()</span><br><span class="line">            self.mutation()</span><br><span class="line">    <span class="comment"># 输出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        popPerform = self.translate()</span><br><span class="line">        idx, best = <span class="number">0</span>, self.fitness(popPerform[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.popSize):</span><br><span class="line">            fx = self.fitness(popPerform[i])</span><br><span class="line">            <span class="keyword">if</span> fx &gt; best:</span><br><span class="line">                idx, best = i, fx</span><br><span class="line">        <span class="built_in">print</span>(popPerform[idx])</span><br><span class="line">        <span class="built_in">print</span>(best)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Rosenbrock_GA = GA(nVar = <span class="number">2</span>, xMin = [-<span class="number">2.048</span>, -<span class="number">2.048</span>], xMax=[<span class="number">2.048</span>, <span class="number">2.048</span>], geneLen = <span class="number">10</span>)</span><br><span class="line">    Rosenbrock_GA.update()</span><br><span class="line">    Rosenbrock_GA.display()</span><br></pre></td></tr></table></figure><p>筛选出最优输出结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-2.04399609 -2.048     ]</span><br><span class="line">3885.4739163295735</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://book.douban.com/subject/1237247/">遗传算法原理及应用 - 周明,孙树栋编著</a></li><li><a href="https://blog.csdn.net/ha_ha_ha233/article/details/91364937?ops_request_misc=%7B%22request%5Fid%22%3A%22166212109416782244822973%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166212109416782244822973&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-91364937-null-null.142^v46^pc_rank_34_1&amp;utm_term=遗传算法&amp;spm=1018.2226.3001.4187">遗传算法详解 附python代码实现_- CSDN(csdn.net)</a></li><li><a href="https://www.jianshu.com/p/ae5157c26af9">超详细的遗传算法(Genetic Algorithm)解析 - 简书 (jianshu.com)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h1&gt;&lt;p&gt;遗传算法（GA）是模拟生物在自然环境中的遗传和进化过程而形成的一种自适应全局优化概率搜索算法。该算法基于达尔文的“适者生存，</summary>
      
    
    
    
    <category term="数学建模" scheme="https://cszhouy.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="python" scheme="https://cszhouy.github.io/tags/python/"/>
    
    <category term="数学建模" scheme="https://cszhouy.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="智能优化算法" scheme="https://cszhouy.github.io/tags/%E6%99%BA%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>粒子群算法</title>
    <link href="https://cszhouy.github.io/blog/fe09d13e.html"/>
    <id>https://cszhouy.github.io/blog/fe09d13e.html</id>
    <published>2022-09-02T01:31:11.000Z</published>
    <updated>2022-10-17T07:14:51.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>粒子群算法（PSO）来源于对一个简化社会模型的模拟，该算法最初是为了图形化地模拟鸟群优美而不可预测的运动。在鸟群觅食过程中，我们假定鸟群中信息共享，每个个体都知道自己与其它个体的当前觅食地点和历史最佳觅食地点，因此个体下一运动状态趋势如下：</p><ul><li>受飞行惯性影响，个体将沿原飞行方向运动</li><li>个体向自己的历史最佳觅食地点运动</li><li>个体向当前鸟群中最佳觅食地点运动</li></ul><p>将这三个运动矢量合成，即可得知下一觅食地点。</p><div align=center><img src="https://pic.imgdb.cn/item/63115e0c16f2c2beb1bd4267.png"></div><p>这是一个迭代过程，我们认为鸟群中个体的运动是同时发生的，并将一次运动过程视为一代，当群体的规模较大且迭代次数较多时，鸟群中所有个体将向该有限空间内的最佳觅食地点靠拢。</p><p>在处理优化问题时，粒子群算法将自变量集合视为个体觅食地点的坐标，将优化目标函数视为觅食地点的评价方法，将自变量在其领域的偏移视为鸟群个体的运动过程，当鸟群聚集于最佳觅食点时，此时自变量的取值刚好满足优化目标的全局最优。</p><h2 id="进化方程"><a href="#进化方程" class="headerlink" title="进化方程"></a>进化方程</h2><p>粒子群算法将每个个体看作$D$维空间中的一个没有体积的微粒，在搜索空间中以一定速度飞行，这个速度根据它本身的飞行经验和同伴的飞行经验来动态调整。第$i$个微粒表示为$X_i=(x_{i1},x_{i2},…,x_{iD})$，它经历过的最好位置（有最好适应值）记为$P_i=(p_{i1},p_{i2},…,p_{iD})$.在群体所有微粒经过的最好位置的索引号用符号$g$表示，即$P_g$. 微粒$i$的速度为$V_i=(v_{i1},v_{i2},…,v_{iD})$，对于每一维度的第$t$代，它的第$t+1$代根据如下方程进行变化：</p><script type="math/tex; mode=display">V_{i}^{t+1}=w\cdot V_i^t + c_1\cdot r_1 \cdot (P_i^t-X_i^t)+c_2 \cdot r_2 \cdot (P_{g}^t-X_i^t)\\~\\X_i^{t+1}=X_i^t+V_i^{t+1}</script><p>参数含义如下：</p><ul><li>$V_i^k$：第$i$个粒子第$k$代的速度，即第$k-1$代到第$k$代的运动矢量</li><li>$X_i^k$：第$i$个粒子第$k$代的位置坐标</li><li>$w$：自身权重系数，取$0.9$到$1.2$较合适</li><li>$c_1$：自身认知常数，取$2.0$较合适</li><li>$c_2$：社会认知常数，取$2.0$较合适</li><li>$r_1,r_2$：区间$[0,1]$内随机数</li><li>$P_i^k$：第$i$个粒子运动到第$k$代时的历史最好位置</li><li>$P_{gi}^k$：所有微粒运动到第$k$代时的历史最好位置</li></ul><p>除了以上在公式中出现的参数，还有其它参数需要注意，如种群规模即粒子数量，粒子位置的范围即自变量定义域，运动速度上下限等。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>$step\ 1$  初始化微粒（群体规模为$m$），微粒的初始位置和速度取随机值</p><p>$step\ 2$  评价每个微粒的适应度（优化目标函数值）</p><p>$step\ 3$  对每个微粒，将它的适应值和它经历过的最好位置<em>pbest</em>的作比较，如果较好，则将其作为该粒子历史最佳位置<em>pbest</em></p><p>$step\ 4$  对每个微粒，将它的适应值和全局所经历最好位置 <em>gbest</em>的作比较，如果较好，则将其作为全局最佳位置<em>gbest</em></p><p>$step\ 5$  依据进化方程更新微粒的速度与位置</p><p>$step\ 6$  如未达到结束条件（通常为足够好的适应值或达到一个预设最大代数 $G_{max}$ ），回到$step\ 2$</p><h1 id="算法案例"><a href="#算法案例" class="headerlink" title="算法案例"></a>算法案例</h1><h2 id="无约束条件"><a href="#无约束条件" class="headerlink" title="无约束条件"></a>无约束条件</h2><p>以<em>Bukin</em>函数为例，其函数形式如下：</p><script type="math/tex; mode=display">f(x)=100\sqrt {|x_2-0.01x_1^2|}+0.01|x_1+10|\\~\\x_1\in [-15, -5],\ x_2\in [-3,3]</script><p>已知该函数在$x^{*}=(-10,1)$时有最小值$0$。下面用粒子群算法求解最优值</p><p>该例中，粒子运动空间的维度为$2$，取种群规模为$100$，更新代数为$500$，速度范围为$[-1,1]，$自身权重因子$0.9$，自身认知常数$2.0$，社会认知常数$2.0$。程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PSO</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size, nVar, xMin, xMax, vMin, vMax, times</span>):</span><br><span class="line">        self.size = size<span class="comment"># 种群规模</span></span><br><span class="line">        self.nVar = nVar<span class="comment"># 空间维数</span></span><br><span class="line">        self.times = times<span class="comment"># 迭代次数</span></span><br><span class="line">        self.x = np.zeros((size, nVar), dtype=<span class="built_in">float</span>)<span class="comment"># 粒子坐标</span></span><br><span class="line">        self.v = np.zeros((size, nVar), dtype=<span class="built_in">float</span>)<span class="comment"># 粒子速度</span></span><br><span class="line">        self.xMin = np.array(xMin, dtype = <span class="built_in">float</span>)<span class="comment"># 粒子位置下限</span></span><br><span class="line">        self.xMax = np.array(xMax, dtype = <span class="built_in">float</span>)<span class="comment"># 粒子位置上限</span></span><br><span class="line">        self.vMin = vMin<span class="comment"># 粒子速度下限</span></span><br><span class="line">        self.vMax = vMax<span class="comment"># 粒子速度上限</span></span><br><span class="line">        <span class="comment"># 粒子坐标与速度随机值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nVar):</span><br><span class="line">                self.x[i][j] = random.uniform(self.xMin[j], self.xMax[j])</span><br><span class="line">                self.v[i][j] = random.uniform(self.vMin, self.vMax)</span><br><span class="line">        <span class="comment"># 单个粒子最有值与全局最优值索引</span></span><br><span class="line">        self.pBest = self.x.copy()</span><br><span class="line">        self.gBest = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fitness</span>(<span class="params">self, x</span>):</span><br><span class="line">        x1 = x[<span class="number">0</span>]</span><br><span class="line">        x2 = x[<span class="number">1</span>]</span><br><span class="line">        f = <span class="number">100</span> * np.sqrt(np.<span class="built_in">abs</span>(x2 - <span class="number">0.01</span>*x1**<span class="number">2</span>)) + <span class="number">0.01</span> * np.<span class="built_in">abs</span>(x1 + <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, w, c1, c2</span>):</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(self.times):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (self.size):</span><br><span class="line">                <span class="comment"># 更新粒子速度</span></span><br><span class="line">                self.v[i] = w * self.v[i] + random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c1 * (self.pBest[i] - self.x[i]) + random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c2 * (self.pBest[self.gBest] - self.x[i])</span><br><span class="line">                <span class="comment"># 确保速度不超过上下限</span></span><br><span class="line">                self.v[i][self.v[i] &lt; self.vMin] = self.vMin</span><br><span class="line">                self.v[i][self.v[i] &gt; self.vMax] = self.vMax</span><br><span class="line">                <span class="comment"># 更新粒子位置</span></span><br><span class="line">                self.x[i] += self.v[i]</span><br><span class="line">                <span class="comment"># 确保位置不超过上下限</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.nVar):</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &gt; self.xMax[j]:</span><br><span class="line">                        self.x[i][j] = self.xMax[j]</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &lt; self.xMin[j]:</span><br><span class="line">                        self.x[i][j] = self.xMin[j]</span><br><span class="line">                <span class="comment"># 比较每个粒子的新的适应度与历史最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[i]):</span><br><span class="line">                    self.pBest[i] = self.x[i]</span><br><span class="line">                <span class="comment"># 比较当前粒子的新适应度与全局最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[self.gBest]):</span><br><span class="line">                    self.gBest = i</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.pBest[self.gBest])</span><br><span class="line">        <span class="built_in">print</span>(self.fitness(self.pBest[self.gBest]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 种群规模为100，更新500代</span></span><br><span class="line">    bukin = PSO(size=<span class="number">100</span>, nVar=<span class="number">2</span>, xMin=[-<span class="number">15</span>, -<span class="number">3</span>], xMax=[-<span class="number">5</span>, <span class="number">3</span>], vMin=-<span class="number">1</span>, vMax=<span class="number">1</span>, times=<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 自身权重因子0.9，自身认知常数2.0，社会认知常数2.0</span></span><br><span class="line">    bukin.update(w = <span class="number">0.9</span>, c1 = <span class="number">2.0</span>, c2 = <span class="number">2.0</span>)</span><br><span class="line">    bukin.display()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>筛选最优输出结果为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-10.77631364   1.16128901]</span><br><span class="line">0.0662286658094341</span><br></pre></td></tr></table></figure></p><h2 id="有约束条件"><a href="#有约束条件" class="headerlink" title="有约束条件"></a>有约束条件</h2><p>与模拟退火算法相同，在处理约束条件时我们依旧采用罚函数的思想，将约束条件转换为限制粒子飞行的因素。</p><script type="math/tex; mode=display">min\ f(x)=0.4x_2 + x_1^2+x_2^2-x_1x_2+ \frac{1}{30}x_1^3\\~\\s.t.\ \begin{cases}x_1+0.5x_2 \geq 0.4\\0.5x_1+x_2 \geq 0.5\\x_1\geq 0, x_2 \geq 0\end{cases}</script><p>对于该例子，利用惩罚函数法，将约束条件转化为惩罚项，定义$P_1=(\min(x_1+0.5x_2-0.4,0))^2$，$P_2=(\min(0.5x_1+x_2-0.5,0))^2$，此时构造新的增广目标函数$min\ F(X,M_t)=f(X)+M_t(P_1+P_2)$，其中$M_t$为惩罚因子。</p><p>粒子运动空间的维度为$2$，取种群规模为$100$，更新代数为$500$，速度范围为$[-1,1]，$自身权重因子$0.9$，自身认知常数$2.0$，社会认知常数$2.0$。该例自变量没有上限，但我们可以粗略估计在最优解时自变量$x_1$，$x_2$都落在$[0,1.0]$内，因此将粒子坐标的上限设为$1.0$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PSO</span>:</span><br><span class="line">    <span class="comment"># 初始化参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size, dim, xMin, xMax, vMin, vMax, times</span>):</span><br><span class="line">        self.size = size<span class="comment"># 种群规模</span></span><br><span class="line">        self.dim = dim<span class="comment"># 空间维度</span></span><br><span class="line">        self.vMin = vMin<span class="comment"># 粒子速度下限</span></span><br><span class="line">        self.vMax = vMax<span class="comment"># 粒子速度上限</span></span><br><span class="line">        self.times = times<span class="comment"># 迭代次数</span></span><br><span class="line">        self.xMin = np.array(xMin, dtype = <span class="built_in">float</span>)<span class="comment"># 粒子坐标下限</span></span><br><span class="line">        self.xMax = np.array(xMax, dtype = <span class="built_in">float</span>)<span class="comment"># 粒子坐标上限</span></span><br><span class="line">        <span class="comment"># 粒子的位置与速度初始值均为随机值</span></span><br><span class="line">        self.x = np.zeros((size, dim), dtype = <span class="built_in">float</span>)</span><br><span class="line">        self.v = np.zeros((size, dim), dtype = <span class="built_in">float</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">                self.x[i][j] = random.uniform(self.xMin[j], self.xMax[j])</span><br><span class="line">                self.v[i][j] = random.uniform(self.vMin, self.vMax)</span><br><span class="line">        <span class="comment"># 单个粒子的最佳坐标和全局最佳坐标</span></span><br><span class="line">        self.pBest = self.x.copy()</span><br><span class="line">        self.gBest = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每一代的全局最优值</span></span><br><span class="line">        self.bestList = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># 带有惩罚项的适应度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fitness</span>(<span class="params">self, x, M</span>):</span><br><span class="line">        x1 = x[<span class="number">0</span>]</span><br><span class="line">        x2 = x[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 目标函数</span></span><br><span class="line">        fx = <span class="number">0.4</span>*x2 + x1**<span class="number">2</span> + x2**<span class="number">2</span> - x1*x2 + (<span class="number">1</span>/<span class="number">30</span>)*(x1**<span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 惩罚项</span></span><br><span class="line">        p1 = (<span class="built_in">min</span>(x1 + <span class="number">0.5</span>*x2 - <span class="number">0.4</span>, <span class="number">0</span>))**<span class="number">2</span></span><br><span class="line">        p2 = (<span class="built_in">min</span>(<span class="number">0.5</span>*x1 + x2 - <span class="number">0.5</span>, <span class="number">0</span>))**<span class="number">2</span></span><br><span class="line">        <span class="comment"># 增广函数</span></span><br><span class="line">        Fx = fx + M*(p1 + p2)</span><br><span class="line">        <span class="keyword">return</span> fx, Fx</span><br><span class="line">    <span class="comment"># 种群更新迭代</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, w, c1, c2</span>):</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(self.times):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.size):</span><br><span class="line">                <span class="comment"># 更新粒子速度</span></span><br><span class="line">                self.v[i] = w*self.v[i] + c1 * random.uniform(<span class="number">0</span>, <span class="number">1</span>) * (self.pBest[i] - self.x[i]) + c2 * random.uniform(<span class="number">0</span>, <span class="number">1</span>) * (self.pBest[self.gBest] - self.x[i])</span><br><span class="line">                self.v[i][self.v[i] &lt; self.vMin] = self.vMin</span><br><span class="line">                self.v[i][self.v[i] &gt; self.vMax] = self.vMax</span><br><span class="line">                <span class="comment"># 更新粒子坐标</span></span><br><span class="line">                self.x[i] = self.x[i] + self.v[i]</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.dim):</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &gt; self.xMax[j]:</span><br><span class="line">                        self.x[i][j] = self.xMax[j]</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &lt; self.xMin[j]:</span><br><span class="line">                        self.x[i][j] = self.xMin[j]</span><br><span class="line">                <span class="comment"># 惩罚因子</span></span><br><span class="line">                M = t**(<span class="number">3</span>/<span class="number">2</span>)</span><br><span class="line">                <span class="comment"># 目标函数值与适应度</span></span><br><span class="line">                fx, Fx = self.fitness(self.x[i], M)</span><br><span class="line">                pBest_fx, pBest_Fx =  self.fitness(self.pBest[i], M)</span><br><span class="line">                gBest_fx, gBest_Fx = self.fitness(self.pBest[self.gBest], M)</span><br><span class="line">                <span class="comment"># 更新单个粒子最优坐标与全局最优坐标</span></span><br><span class="line">                <span class="keyword">if</span> Fx &lt; pBest_Fx:</span><br><span class="line">                    self.pBest[i] = self.x[i]</span><br><span class="line">                <span class="comment"># 比较当前粒子的新适应度与全局最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> Fx &lt; gBest_Fx:</span><br><span class="line">                    self.gBest = i</span><br><span class="line">            self.bestList.append(self.fitness(self.pBest[self.gBest], M)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.pBest[self.gBest])</span><br><span class="line">        <span class="built_in">print</span>(self.fitness(self.pBest[self.gBest], <span class="number">0</span>)[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 绘图</span></span><br><span class="line">        plt.plot(self.bestList)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pso = PSO(size=<span class="number">100</span>, dim=<span class="number">2</span>, xMin=[<span class="number">0</span>, <span class="number">0</span>], xMax=[<span class="number">1.0</span>, <span class="number">1.0</span>], vMin=-<span class="number">1</span>, vMax=<span class="number">1</span>, times=<span class="number">500</span>)</span><br><span class="line">    pso.update(w = <span class="number">0.9</span>, c1 = <span class="number">2.0</span>, c2 = <span class="number">2.0</span>)</span><br><span class="line">    pso.display()</span><br></pre></td></tr></table></figure><p>输出结果为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0.34072776 0.32958779]</span><br><span class="line">0.2455774890528109</span><br></pre></td></tr></table></figure></p><div align=center><img src="https://pic.imgdb.cn/item/63115e1116f2c2beb1bd456a.png"></div>从图像中可以看出，在20代左右全局最优值已经趋于稳定，并接近最终解。**需要注意，从图像上看，最初几代的全局最优值要比最终结果更小，这是因为该图像纵坐标表示优化目标函数值$f(x)$，不包含惩罚项。这时函数值虽然更小，但变量并不满足约束条件。** 这与解空间上限的取值有关，读者不妨取其它值试验，观察图像的差异。# 改进算法## 二阶粒子群算法粒子群算法是一种简单高效的优化算法，但其很容易陷入局部最优。在第$t$代，粒子$i$的实际运动速率为$v_i^t$为$x_i^t-x_i^{t-1}$，若仅考虑粒子向个体最佳位置*pbest*运动，粒子的速度变化率为$$v_i^{t+1}-v_i^t=(P_i-x_i^t)-(x_i^t-x_i^{t-1})=P_i-2x_i^t+x_i^{t-1}$$仅考虑粒子向全局最佳位置*gbest*运动，粒子的速度变化率为$$v_i^{t+1}-v_i^t=(P_g-x_i^t)-(x_i^t-x_i^{t-1})=P_g-2x_i^t+x_i^{t-1}$$当同时考虑个体最佳位置与全局最佳位置的影响时，微粒的速度变化率应为上述两种情况的随机加权，并在算法中引入**惯性权重$w$** 来平衡算法的全局搜索能力与局部搜索能力。设$\varphi_1$为$c_1r_1$，$\varphi_2$为$c_1r_1$ ,得到二阶PSO算法的进化方程如下$$v_i^{t+1}=wv_i^t+\varphi_1(P_i-2x_i^t+x_i^{t-1})+\varphi_2(P_g-2x_i^t+x_i^{t-1})\\~\\x_i^{t+1}=x_i^t+v_i^{t+1}$$<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update2d</span>(<span class="params">self, w, c1, c2</span>):</span><br><span class="line">        <span class="keyword">for</span> iterator <span class="keyword">in</span> <span class="built_in">range</span>(self.times):</span><br><span class="line">            <span class="comment"># 上一代粒子的位置，初始为所有粒子的初始位置</span></span><br><span class="line">            xPrev = self.x.copy()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (self.size):</span><br><span class="line">                <span class="comment"># 更新粒子速度</span></span><br><span class="line">                self.v[i] = w * self.v[i] + random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c1 * (self.pBest[i] - <span class="number">2</span>*self.x[i] + xPrev[i]) + random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c2 * (self.pBest[self.gBest] - <span class="number">2</span>*self.x[i] + xPrev[i])</span><br><span class="line">                <span class="comment"># 确保速度不超过上下限</span></span><br><span class="line">                self.v[i][self.v[i] &lt; self.vMin] = self.vMin</span><br><span class="line">                self.v[i][self.v[i] &gt; self.vMax] = self.vMax</span><br><span class="line">                <span class="comment"># 更新粒子位置</span></span><br><span class="line">                self.x[i] += self.v[i]</span><br><span class="line">                <span class="comment"># 确保位置不超过上下限</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.nVar):</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &gt; self.xMax[j]:</span><br><span class="line">                        self.x[i][j] = self.xMax[j]</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &lt; self.xMin[j]:</span><br><span class="line">                        self.x[i][j] = self.xMin[j]</span><br><span class="line">                <span class="comment"># 比较每个粒子的新的适应度与历史最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[i]):</span><br><span class="line">                    self.pBest[i] = self.x[i]</span><br><span class="line">                <span class="comment"># 比较当前粒子的新适应度与全局最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[self.gBest]):</span><br><span class="line">                    self.gBest = i</span><br></pre></td></tr></table></figure>仍以*Bukin*函数为例，筛选出的最优结果为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-10.39337108   1.08022159]</span><br><span class="line">0.0219605855713847</span><br></pre></td></tr></table></figure>相较于标准的粒子群算法，二阶粒子群算法仅对进化方程进行改动，改进效果并不明显。## 二阶振荡粒子群算法为了进一步提高群体的多样性，可考虑在二阶粒子群算法中引入一个振荡环节，来改善算法的全局收敛性。其进化方程描述如下$$v_i^{t+1}=wv_i^{t}+\varphi_1(P_i-(1+\xi_1)x_i^t+\xi_2x_i^{t-1})+\varphi_2(P_g-(1+\xi_3)x_i^t+\xi_4x_i^{t-1})\\~\\x_i^{t+1}=x_i^t+v_i^{t+1}$$当$0<\xi_2<\frac{1+\xi_1}{2}$，$0<\xi_4<\frac{1+\xi_3}{2}$，$0<\xi_1<1$，$0<\xi_3<1$时，算法振荡收敛；当$\xi_1<\xi_2-1$，$\xi_3<\xi_4-1$，$0<\xi_2<1$，$0<\xi_4<1$时，算法渐进收敛。<div align=center><img src="https://pic.imgdb.cn/item/63115e3016f2c2beb1bd5286.png"></div><div align=center><img src="https://pic.imgdb.cn/item/63115e3416f2c2beb1bd5413.png"></div><p>在全局算法中，一般地，希望算法前期有较高的搜索能力以得到合适的种子，而在后期有较高的开发能力以加快收敛速度。也就是希望算法前期全局搜索能力较强，后期剧不搜索能力较强。因此，PSO算法做如下更改：</p><blockquote><p><strong>$step\ 4$  依据二阶振荡PSO进化方程更新微粒的速度与位置。当前代数$t&lt;G_{max}/2$时，取$0&lt;\xi_2&lt;\frac{1+\xi_1}{2}$，$0&lt;\xi_4&lt;\frac{1+\xi_3}{2}$，$0&lt;\xi_1&lt;1$，$0&lt;\xi_3&lt;1$；当前代数$t\geq G_{max}/2$时，取$\xi_1&lt;\xi_2-1$，$\xi_3&lt;\xi_4-1$，$0&lt;\xi_2&lt;1$，$0&lt;\xi_4&lt;1$.</strong></p></blockquote><p>二阶振荡粒子群算法程序如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update2dvib</span>(<span class="params">self, w, c1, c2</span>):</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(self.times):</span><br><span class="line">            <span class="comment"># 上一代粒子的位置，初始为所有粒子的初始位置</span></span><br><span class="line">            xPrev = self.x.copy()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (self.size):</span><br><span class="line">                <span class="comment"># 设置参数</span></span><br><span class="line">                phi1 = random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c1</span><br><span class="line">                phi2 = random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c2</span><br><span class="line">                <span class="comment"># 振荡因子在前半段和后半段取值不同</span></span><br><span class="line">                <span class="keyword">if</span> t &lt; self.times/<span class="number">2</span>:</span><br><span class="line">                    xi1 = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                    xi3 = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                    xi2 = random.uniform(<span class="number">0</span>, (<span class="number">1</span> + xi1)/<span class="number">2</span>)</span><br><span class="line">                    xi4 = random.uniform(<span class="number">0</span>, (<span class="number">1</span> + xi3)/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    xi2 = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                    xi4 = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                    xi1 = random.uniform(<span class="number">0</span>, xi2 - <span class="number">1</span>)</span><br><span class="line">                    xi3 = random.uniform(<span class="number">0</span>, xi4 - <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 二阶振荡粒子群算法进化方程</span></span><br><span class="line">                self.v[i] = w * self.v[i] + phi1 * (self.pBest[i] - (<span class="number">1</span>+xi1)*self.x[i] + xi2 * xPrev[i]) + phi2 * (self.pBest[self.gBest] - (<span class="number">1</span>+xi3)*self.x[i] + xi4 * xPrev[i])</span><br><span class="line">                <span class="comment"># 确保速度不超过上下限</span></span><br><span class="line">                self.v[i][self.v[i] &lt; self.vMin] = self.vMin</span><br><span class="line">                self.v[i][self.v[i] &gt; self.vMax] = self.vMax</span><br><span class="line">                <span class="comment"># 更新粒子位置</span></span><br><span class="line">                self.x[i] += self.v[i]</span><br><span class="line">                <span class="comment"># 确保位置不超过上下限</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.nVar):</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &gt; self.xMax[j]:</span><br><span class="line">                        self.x[i][j] = self.xMax[j]</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &lt; self.xMin[j]:</span><br><span class="line">                        self.x[i][j] = self.xMin[j]</span><br><span class="line">                <span class="comment"># 比较每个粒子的新的适应度与历史最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[i]):</span><br><span class="line">                    self.pBest[i] = self.x[i]</span><br><span class="line">                <span class="comment"># 比较当前粒子的新适应度与全局最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[self.gBest]):</span><br><span class="line">                    self.gBest = i</span><br></pre></td></tr></table></figure><br>依旧以<em>Bukin</em>函数为例，筛选出的最优结果为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-10.   1.]</span><br><span class="line">0.0</span><br></pre></td></tr></table></figure><br>可以看到结果非常接近标准最优解，这说明二阶振荡PSO算法相较于二阶PSO算法与标准PSO算法精度得到很大提升。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/398856271">数学建模：非常通俗易懂的粒子群算法（PSO）入门 - 知乎 (zhihu.com)</a></li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=494215">A new optimizer using particle swarm theory</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96">粒子群优化 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://www.sfu.ca/~ssurjano/bukin6.html">Bukin Function N. 6 (sfu.ca)</a></li><li><a href="https://www.cnki.com.cn/Article/CJFDTOTAL-JFYZ200711004.htm">二阶微粒群算法—《计算机研究与发展》2007年11期 (cnki.com.cn)</a></li><li><a href="https://www.cnki.com.cn/Article/CJFDTotal-JSGG201909021.htm">改进的二阶振荡粒子群算法—《计算机工程与应用》2019年09期 (cnki.com.cn)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h1&gt;&lt;p&gt;粒子群算法（PSO）来源于对一个简化社会模型的模拟，该算法最初是为了图形化地模拟鸟群优美而不可预测的运动。在鸟群觅食过程中，</summary>
      
    
    
    
    <category term="数学建模" scheme="https://cszhouy.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="python" scheme="https://cszhouy.github.io/tags/python/"/>
    
    <category term="数学建模" scheme="https://cszhouy.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="智能优化算法" scheme="https://cszhouy.github.io/tags/%E6%99%BA%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火算法</title>
    <link href="https://cszhouy.github.io/blog/a0d601b7.html"/>
    <id>https://cszhouy.github.io/blog/a0d601b7.html</id>
    <published>2022-08-23T14:05:01.000Z</published>
    <updated>2022-10-17T07:14:51.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>模拟退火算法是一种优化算法，该算法得益于材料统计力学的研究成果。统计力学表明材料中的粒子在高温条件下能量较高，可以自由运动和重新排列；在低温条件下，粒子能量较低，运动的剧烈程度也低。如果从高温开始非常缓慢地降温（退火），粒子就可以在每个温度下达到热平衡，当系统完全冷却时，最终形成处于低能状态的晶体。</p><p>假设材料在状态$i$下的状态为$E(i)$，则材料在温度T时从状态$i$进入状态$j$遵循如下规律：</p><ul><li>如果$E(j)\leq E(i)$，则接受该状态</li><li>如果$E(j)&gt;E(i)$，则以概率$e^\frac{E(i)-E(j)}{KT}$接受该状态。其中$e$是自然对数的底数，$K$是玻尔兹曼常数，$T$是材料温度。</li></ul><p>模拟退火算法需要确定优化目标，通过迭代的退火过程，得到最后的最优解。具体的算法步骤如下：</p><ol><li>确定优化目标。优化目标通常是求一个或多个函数的最大值或最小值</li><li>任选一初始状态$s_0$作为初始解$s(0)=s_0$，并设初始温度为$T_0$，令$i$等于0</li><li>按某一种规定的方式对当前解$s(i)$扰动，产生一个新解$s’$</li><li>对新解$s’$进行评价<ul><li>若新解$s’$优于当前解$s(i)$，则将其作为下一个当前解$s(i+1)$</li><li>否则依据概率$e^{-\frac{\Delta C}{T}}$接受该解，将其作为下一个当前解. $\Delta C$是优化目标函数值之差的绝对值</li></ul></li><li>按一定方式将T降温，令$i=i+1$，$T_i=w(T_i)$</li><li>检查退火过程是否结束，若未结束则跳转到3，否则跳转到7</li><li>以当前解$s_i$作为最优解输出</li></ol><p>需要注意：</p><ol><li><p><strong>模拟退火算法求得的最优解通常为近似解，并非精确解</strong></p><p> 该算法在每一次迭代中产生的新解$s’$是随机选择当前解的一个临近子集中的值，随机选择的范围与温度有关，因此并不能确保新解会命中精确的最优解。但随着迭代次数的提高与温度的降低，新解会不断靠近最优解。</p></li><li><p><strong>模拟退火算法求得的最优解理论上为全局最优解</strong></p><p> 该算法在评价新解$s’$是否作为下一个当前解$s(i+1)$时，在新解$s’$未优于当前解$s(i)$的情况下并没有抛弃新解，而是依概率接受新解，这样可以确保每次迭代的解都能双向移动。概率与$s’$和$s(i)$优化程度的差值有关，也与当前温度有关。求出局部最优解的可能性仍然存在。<br><div align=center><img src="https://pic.imgdb.cn/item/6304e0bb16f2c2beb1ee10f0.png"></div><br>如上图，当前解为$x$时，若产生新解为$x_2$，尽管新解未优于当前解，但很明显全局最优解在$x$左侧，若直接舍弃$x_2$，则会导致新解的一直落在当前解的右侧，最终导致陷入局部最优解。</p></li></ol><h1 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h1><h2 id="单变量函数优化"><a href="#单变量函数优化" class="headerlink" title="单变量函数优化"></a>单变量函数优化</h2><p>问题：对于给定的$n$，求$\sqrt{n}$。</p><p>设$x$为$\sqrt{n}$的最优解，当$x^2$与$n$越接近，x的值就越精确。因此问题的优化目标如下：</p><script type="math/tex; mode=display">min\quad |x^2-n|</script><p>初始温度设为$1000$，温度变化率设为$1\%$，最低温度边界为$10^{-5}$，初始最优解可以是定义域内的任意值，本文取$x_0=0$. 程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math  </span><br><span class="line"><span class="comment"># 定义优化目标函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">opt_func</span>(<span class="params">x, n</span>):</span><br><span class="line">    <span class="keyword">return</span> math.fabs(x*x - n)</span><br><span class="line"><span class="comment"># 模拟退火算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SA</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 定义初始温度与温度边界</span></span><br><span class="line">    tInit, tFinal = <span class="number">1000</span>, <span class="number">1e-10</span> </span><br><span class="line">    <span class="comment"># 温度降低系数</span></span><br><span class="line">    dt =  <span class="number">0.99</span>    </span><br><span class="line">    <span class="comment"># 变量，初始值为随机值</span></span><br><span class="line">    x = <span class="number">0</span>  </span><br><span class="line">    <span class="comment"># 函数值</span></span><br><span class="line">    f = opt_func(x, n)</span><br><span class="line">    t = tInit</span><br><span class="line">    <span class="comment"># 退火过程</span></span><br><span class="line">    <span class="keyword">while</span> t &gt; tFinal:</span><br><span class="line">        <span class="comment"># 对变量进行干扰</span></span><br><span class="line">        xNew = x + t * random.normalvariate(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 确保变量在定义域中</span></span><br><span class="line">        <span class="keyword">while</span> xNew &lt; <span class="number">0</span>:</span><br><span class="line">            xNew = x + t * random.normalvariate(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        fNew = opt_func(xNew, n)</span><br><span class="line">        <span class="comment"># 如果新解优于当前解，则将新解作为下一个当前解</span></span><br><span class="line">        <span class="keyword">if</span> fNew &lt; f:</span><br><span class="line">            x = xNew</span><br><span class="line">            f = fNew</span><br><span class="line">        <span class="comment"># 否则按一定概率接受新解</span></span><br><span class="line">        <span class="keyword">elif</span> math.exp(-(fNew - f) / t) &gt; random.random():</span><br><span class="line">            x = xNew</span><br><span class="line">            f = fNew</span><br><span class="line">        <span class="comment"># 降温</span></span><br><span class="line">        t *= dt </span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    SA(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>当n取10时，程序的结果为3.16227766，f非常接近$\sqrt{10}$。如果增加初始温度<code>T</code>，减小温度变化率<code>dT</code>和温度边界<code>Tep</code>可提升精度。但增加迭代次数将会导致算法时间开销增加。</p><h2 id="多变量函数优化"><a href="#多变量函数优化" class="headerlink" title="多变量函数优化"></a>多变量函数优化</h2><p>多变量函数优化需要考虑对每一个变量都进行扰动，因此在每个温度状态下将新增一个内层循环。<strong>在内层循环的每次迭代过程中，既可以随机对某一变量进行扰动，其他变量不变；也可以对每个变量同时扰动。</strong>该过程是一个Markov过程，每个变量的取值仅与前一个变量的取值相关，内层循环的迭代次数为Markov链的长度。</p><p>以智能优化算法的标准测试函数Schwefel为例。Schwefel的形式为：</p><script type="math/tex; mode=display">f(x)=418.9829d-\sum_{i=1}^dx_i\sin(\sqrt{|x_i|})\quad x_i\in[-500,500]</script><div align=center><img src="https://pic.imgdb.cn/item/6304e0fc16f2c2beb1ee2d22.png"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SA</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nVar</span>):</span><br><span class="line">        self.d = nVar <span class="comment">#变量个数</span></span><br><span class="line">        self.x = np.zeros((nVar))   <span class="comment"># 变量值</span></span><br><span class="line">        self.f = self.optimize(self.x)   <span class="comment"># 优化函数值</span></span><br><span class="line">        self.xMin = [-<span class="number">500</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nVar)] <span class="comment"># 下限</span></span><br><span class="line">        self.xMax = [<span class="number">500</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nVar)]  <span class="comment"># 上限</span></span><br><span class="line">        self.tInit = <span class="number">1000</span><span class="comment"># 初始温度</span></span><br><span class="line">        self.dt = <span class="number">0.995</span><span class="comment"># 温度变化率</span></span><br><span class="line">        self.tFinal = <span class="number">1e-10</span><span class="comment"># 温度边界</span></span><br><span class="line">        self.markov = <span class="number">100</span> <span class="comment"># Markov链</span></span><br><span class="line">    <span class="comment"># 优化目标函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">optimize</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.d):</span><br><span class="line">            <span class="built_in">sum</span> += X[i] * np.sin(np.sqrt(<span class="built_in">abs</span>(X[i])))</span><br><span class="line">        fx = <span class="number">418.9829</span> * self.d - <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> fx</span><br><span class="line">    <span class="comment"># 退火过程</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        t = self.tInit</span><br><span class="line">        <span class="comment"># 新解</span></span><br><span class="line">        xNew = np.zeros((self.d))</span><br><span class="line">        <span class="keyword">while</span> t &gt; self.tFinal:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.markov):</span><br><span class="line">                <span class="comment"># 对其中一个变量扰动，其它变量不变</span></span><br><span class="line">                v = random.randint(<span class="number">0</span>, self.d-<span class="number">1</span>)</span><br><span class="line">                xNew[v] = self.x[v] + t * ((self.xMax[v] - self.xMin[v])/self.tInit) * random.normalvariate(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">while</span> xNew[v] &lt; self.xMin[v] <span class="keyword">or</span> xNew[v] &gt; self.xMax[v]:</span><br><span class="line">                    xNew[v] = self.x[v] + t * ((self.xMax[v] - self.xMin[v])/self.tInit) * random.normalvariate(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                fNew = self.optimize(xNew)</span><br><span class="line">                <span class="comment"># 当新解优于当前解，接受新解</span></span><br><span class="line">                <span class="keyword">if</span> fNew &lt; self.f:</span><br><span class="line">                    self.f = fNew</span><br><span class="line">                    self.x[:] = xNew[:]</span><br><span class="line">                <span class="comment"># 否则以一定概率接受新解</span></span><br><span class="line">                <span class="keyword">elif</span> math.exp(-(fNew - self.f)/t) &gt; random.random():</span><br><span class="line">                    self.f = fNew</span><br><span class="line">                    self.x[:] = xNew[:]</span><br><span class="line">            <span class="comment"># 降温</span></span><br><span class="line">            t *= self.dt  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.x)</span><br><span class="line">        <span class="built_in">print</span>(self.f)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sa = SA(<span class="number">2</span>)</span><br><span class="line">    sa.run()</span><br><span class="line">    sa.display()</span><br></pre></td></tr></table></figure><p>当变量个数为2时，筛选出最优结果为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[420.92878528 421.02752236]</span><br><span class="line">0.000662878735056438</span><br></pre></td></tr></table></figure><br>输出结果的值是随机的，但大部分围绕标准解波动。程序有时会输出偏差较大的值，说明此时的结果落在了局部最优解附近，<strong>这种情况与温度及其变化率的设置有关，也与对变量扰动的处理方法有关</strong>。该程序内层循环的每次迭代仅对一个变量进行扰动，且扰动幅度相同，这可能导致变量之间的偏差较大，从而偏离标准解。</p><h1 id="约束条件的处理"><a href="#约束条件的处理" class="headerlink" title="约束条件的处理"></a>约束条件的处理</h1><p>此处所说的约束条件是指不同变量之间的约束关系，而非单个变量的上下限约束。</p><p>对于不等式约束条件，可在模拟退火算法的迭代过程中将每次产生的新解代入约束函数，如果满足约束条件则保留；如果不满足约束条件则舍弃该解并重新生成新解并检验，直到满足所有约束条件为止。对于等式约束，可以采用等式代换的方法进行消元，仅保留不等式约束，再按以上方法对新解进行检验。</p><p>这种检验法思路简单，但在约束条件繁多且苛刻的情况下，该方法的时间开销将会相当大。下文将介绍另一种通用的方法。</p><h2 id="惩罚函数法"><a href="#惩罚函数法" class="headerlink" title="惩罚函数法"></a>惩罚函数法</h2><p>惩罚函数法（SUMT）又称为序列无约束最优化方法，它通过对约束条件加权将约束优化问题转化为无约束优化问题。</p><p>对于以下的约束优化问题：</p><script type="math/tex; mode=display">min\  f(X)\quad X=[x_1,x_2,...,x_n]\\\\\\~\\\\\\s.t.\ \begin{cases}g_i(X)\leq 0 & i=1,2,...,m\\\\\\h_j(X)=0 & j=1,2,...,l\\\\\\r_k(X)\geq 0 & k=1,2,...,q\end{cases}</script><p>根据惩罚函数法，将约束最优化问题转换为增广目标函数极小值问题：</p><script type="math/tex; mode=display">min\  F(X,M_t)=min\  \lbrace f(X)+M_t·(P_1(X)+P_2(X)+P_3(X))\rbrace \\\\\\~\\\\\\P_1(X)=\sum_{i=1}^{m}[\max(g_i(X),0)]^2\\\\\\P_2(X)=\sum_{j=1}^{l}[h_j(X)]^2\\\\\\P_3(X)=\sum_{k=1}^{q}[\min(0,r_k(X))]^2\\\\\\</script><p>其中$\lbrace M_t\rbrace$为一单调增加正序列，即$M_1<M_2<...<M_t$，$f(X)$为不加惩罚函数项的目标函数，$P(X)$称为惩罚函数，$M_t$称为惩罚因子，$M_t·P(X)$称为惩罚项。在$P(X)$中对于不满足约束条件的点$X$，惩罚项$M_t·P(X)>0$，且随着$M_k$的增大而增大，这是对不满足约束条件时的一种惩罚。当$P(X)$充分小时$X(M_t)$将充分接近约束区域的边界，就可以认为$X(M_t)$是满足约束条件的最小点。</p><h2 id="带约束条件的单目标优化"><a href="#带约束条件的单目标优化" class="headerlink" title="带约束条件的单目标优化"></a>带约束条件的单目标优化</h2><p>有非线性单目标目标优化如下：</p><script type="math/tex; mode=display">min\ f(X)=x_1x_4(x_1+x_2+x_3)+x_3\\\\\\~\\\\\\s.t.\ \begin{cases}x_1x_2x_3x_4\geq25\\\\\\{x_1}^2+{x_2}^2+{x_3}^2+{x_4}^2=40\\\\\\1\leq x_1,x_2,x_3,x_4\leq 5\end{cases}</script><p>利用惩罚函数法，将约束条件转化为惩罚函数，其中定义$P_1(X)=(\min(x_1x_2x_3x_4-25,0))^2$，$P_2(X)=(x_1^2+x_2^2+x_3^2+x_4^2-40)^2$，此时构造新的增广目标函数$min\ F(X,M_t)=f(X)+M_t(P_1(X)+P_2(X))$，其中$M_t$为惩罚因子。</p><p>惩罚因子$M_t$随外层循环逐渐增大，在内层循环保持不变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SA</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.tInit = <span class="number">10000</span><span class="comment"># 初始温度</span></span><br><span class="line">        self.tFinal = <span class="number">1e-15</span><span class="comment"># 温度边界</span></span><br><span class="line">        self.dt = <span class="number">0.999</span> <span class="comment"># 降温系数</span></span><br><span class="line">        self.markov = <span class="number">100</span> <span class="comment"># 马尔可夫链长</span></span><br><span class="line">        self.X = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]<span class="comment"># 变量</span></span><br><span class="line">        self.xMin = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]<span class="comment"># 变量下限</span></span><br><span class="line">        self.xMax = [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]<span class="comment"># 变量上限</span></span><br><span class="line">        self.F = <span class="number">0</span>  <span class="comment"># 目标函数值 </span></span><br><span class="line">        self.M = <span class="number">1</span><span class="comment"># 惩罚因子</span></span><br><span class="line">        self.delta = <span class="number">1.01</span> <span class="comment"># 惩罚因子增长系数</span></span><br><span class="line">        self.scale = <span class="number">0.5</span>  <span class="comment"># 内循环搜索步长</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">optimize</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># 惩罚函数</span></span><br><span class="line">        P0 = (<span class="built_in">min</span>(<span class="number">0</span>, X[<span class="number">0</span>]*X[<span class="number">1</span>]*X[<span class="number">2</span>]*X[<span class="number">3</span>]-<span class="number">25</span>))**<span class="number">2</span></span><br><span class="line">        P1 = (X[<span class="number">0</span>]**<span class="number">2</span> + X[<span class="number">1</span>]**<span class="number">2</span> + X[<span class="number">2</span>]**<span class="number">2</span> + X[<span class="number">3</span>]**<span class="number">2</span> - <span class="number">40</span>)**<span class="number">2</span> </span><br><span class="line">        <span class="comment"># 优化目标函数</span></span><br><span class="line">        fx = X[<span class="number">0</span>] * X[<span class="number">3</span>] * (X[<span class="number">0</span>] + X[<span class="number">1</span>] + X[<span class="number">2</span>]) + X[<span class="number">2</span>]</span><br><span class="line">        <span class="comment"># 新的优化目标</span></span><br><span class="line">        F = fx + self.M*(P0 + P1)</span><br><span class="line">        <span class="keyword">return</span> F</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        xNew = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        t = self.tInit</span><br><span class="line">        self.F = self.optimize(self.X)</span><br><span class="line">        <span class="keyword">while</span> t &gt; self.tFinal:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.markov):</span><br><span class="line">                v = random.randint(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">                xNew[v] = self.X[v] + self.scale*random.normalvariate(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">while</span> xNew[v] &lt; self.xMin[v] <span class="keyword">or</span> xNew[v] &gt; self.xMax[v]:</span><br><span class="line">                    xNew[v] = self.X[v] + self.scale*random.normalvariate(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                fNew = self.optimize(xNew)</span><br><span class="line">                <span class="keyword">if</span> fNew &lt; self.F:</span><br><span class="line">                    self.F = fNew</span><br><span class="line">                    self.X[:] = xNew[:]</span><br><span class="line">                    <span class="comment"># self.scale *= self.dt</span></span><br><span class="line">                <span class="keyword">elif</span> math.exp(-(fNew - self.F)/t) &gt; random.random():</span><br><span class="line">                    self.F = fNew</span><br><span class="line">                    self.X[:] = xNew[:]</span><br><span class="line">                <span class="comment"># 减小搜索步长</span></span><br><span class="line">                self.scale *= self.dt</span><br><span class="line">            <span class="comment"># 降温</span></span><br><span class="line">            t *= self.dt</span><br><span class="line">            <span class="comment"># 增加惩罚因子</span></span><br><span class="line">            self.M *= self.delta</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;X:&#x27;</span>, self.X)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;F(x)&#x27;</span>, self.F)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;opt&#x27;</span>, self.X[<span class="number">0</span>] * self.X[<span class="number">3</span>] * (self.X[<span class="number">0</span>] + self.X[<span class="number">1</span>] + self.X[<span class="number">2</span>]) + self.X[<span class="number">2</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;M&#x27;</span>, self.M)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sa = SA()</span><br><span class="line">    sa.run()</span><br><span class="line">    sa.display()</span><br></pre></td></tr></table></figure><br>程序经过多次运行后筛选最优值为$x_1=2.0962,x_2=1.0982,x_3=1.4561,x_4=3.0498$，优化目标函数值为$31.187$。但是该结果与最优结果仍有较大差距，这说明程序有欠缺之处，也与模拟退火算法的随机性有关。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.sfu.ca/~ssurjano/schwef.html">Schwefel Function (sfu.ca)</a></li><li><a href="https://www.tocry.cn/archives/simulated-annealing#toc-head-9">速通模拟退火 - Don’t Cry！ (tocry.cn)</a></li><li><a href="https://blog.csdn.net/youcans/article/details/116371882?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166126197116782414971228%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=166126197116782414971228&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-116371882-null-null.nonecase&amp;utm_term=%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4450"> Python数模笔记-模拟退火算法（2）约束条件的处理</a></li><li><a href="https://book.douban.com/subject/35066598/">《Python数学实验与建模 》司守奎 孙玺菁 主编</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h1&gt;&lt;p&gt;模拟退火算法是一种优化算法，该算法得益于材料统计力学的研究成果。统计力学表明材料中的粒子在高温条件下能量较高，可以自由运动和</summary>
      
    
    
    
    <category term="数学建模" scheme="https://cszhouy.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="python" scheme="https://cszhouy.github.io/tags/python/"/>
    
    <category term="数学建模" scheme="https://cszhouy.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="智能优化算法" scheme="https://cszhouy.github.io/tags/%E6%99%BA%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://cszhouy.github.io/blog/4a17b156.html"/>
    <id>https://cszhouy.github.io/blog/4a17b156.html</id>
    <published>2022-08-17T13:46:20.937Z</published>
    <updated>2022-10-17T07:14:51.835Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
