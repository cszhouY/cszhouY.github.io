<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zhou Yee">





<title>粒子群算法 | Zhou Yee&#39;s Blog</title>



    <link rel="icon" href="/zhifeiji.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">主页</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">主页</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开全部</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">前往底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '展开全部' : '折叠全部';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">粒子群算法</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">Zhou Yee</a>
                    

                    
                        <span class="post-time">
                        发表时间: <a href="#">九月 2, 2022&nbsp;&nbsp;9:31:11</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类:
                            
                                <a href="/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/">数学建模</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>粒子群算法（PSO）来源于对一个简化社会模型的模拟，该算法最初是为了图形化地模拟鸟群优美而不可预测的运动。在鸟群觅食过程中，我们假定鸟群中信息共享，每个个体都知道自己与其它个体的当前觅食地点和历史最佳觅食地点，因此个体下一运动状态趋势如下：</p>
<ul>
<li>受飞行惯性影响，个体将沿原飞行方向运动</li>
<li>个体向自己的历史最佳觅食地点运动</li>
<li>个体向当前鸟群中最佳觅食地点运动</li>
</ul>
<p>将这三个运动矢量合成，即可得知下一觅食地点。</p>
<div align=center><img src="https://pic.imgdb.cn/item/63115e0c16f2c2beb1bd4267.png"></div>

<p>这是一个迭代过程，我们认为鸟群中个体的运动是同时发生的，并将一次运动过程视为一代，当群体的规模较大且迭代次数较多时，鸟群中所有个体将向该有限空间内的最佳觅食地点靠拢。</p>
<p>在处理优化问题时，粒子群算法将自变量集合视为个体觅食地点的坐标，将优化目标函数视为觅食地点的评价方法，将自变量在其领域的偏移视为鸟群个体的运动过程，当鸟群聚集于最佳觅食点时，此时自变量的取值刚好满足优化目标的全局最优。</p>
<h2 id="进化方程"><a href="#进化方程" class="headerlink" title="进化方程"></a>进化方程</h2><p>粒子群算法将每个个体看作$D$维空间中的一个没有体积的微粒，在搜索空间中以一定速度飞行，这个速度根据它本身的飞行经验和同伴的飞行经验来动态调整。第$i$个微粒表示为$X_i=(x_{i1},x_{i2},…,x_{iD})$，它经历过的最好位置（有最好适应值）记为$P_i=(p_{i1},p_{i2},…,p_{iD})$.在群体所有微粒经过的最好位置的索引号用符号$g$表示，即$P_g$. 微粒$i$的速度为$V_i=(v_{i1},v_{i2},…,v_{iD})$，对于每一维度的第$t$代，它的第$t+1$代根据如下方程进行变化：</p>
<script type="math/tex; mode=display">
V_{i}^{t+1}=w\cdot V_i^t + c_1\cdot r_1 \cdot (P_i^t-X_i^t)+c_2 \cdot r_2 \cdot (P_{g}^t-X_i^t)\\
~\\
X_i^{t+1}=X_i^t+V_i^{t+1}</script><p>参数含义如下：</p>
<ul>
<li>$V_i^k$：第$i$个粒子第$k$代的速度，即第$k-1$代到第$k$代的运动矢量</li>
<li>$X_i^k$：第$i$个粒子第$k$代的位置坐标</li>
<li>$w$：自身权重系数，取$0.9$到$1.2$较合适</li>
<li>$c_1$：自身认知常数，取$2.0$较合适</li>
<li>$c_2$：社会认知常数，取$2.0$较合适</li>
<li>$r_1,r_2$：区间$[0,1]$内随机数</li>
<li>$P_i^k$：第$i$个粒子运动到第$k$代时的历史最好位置</li>
<li>$P_{gi}^k$：所有微粒运动到第$k$代时的历史最好位置</li>
</ul>
<p>除了以上在公式中出现的参数，还有其它参数需要注意，如种群规模即粒子数量，粒子位置的范围即自变量定义域，运动速度上下限等。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>$step\ 1$  初始化微粒（群体规模为$m$），微粒的初始位置和速度取随机值</p>
<p>$step\ 2$  评价每个微粒的适应度（优化目标函数值）</p>
<p>$step\ 3$  对每个微粒，将它的适应值和它经历过的最好位置<em>pbest</em>的作比较，如果较好，则将其作为该粒子历史最佳位置<em>pbest</em></p>
<p>$step\ 4$  对每个微粒，将它的适应值和全局所经历最好位置 <em>gbest</em>的作比较，如果较好，则将其作为全局最佳位置<em>gbest</em></p>
<p>$step\ 5$  依据进化方程更新微粒的速度与位置</p>
<p>$step\ 6$  如未达到结束条件（通常为足够好的适应值或达到一个预设最大代数 $G_{max}$ ），回到$step\ 2$</p>
<h1 id="算法案例"><a href="#算法案例" class="headerlink" title="算法案例"></a>算法案例</h1><h2 id="无约束条件"><a href="#无约束条件" class="headerlink" title="无约束条件"></a>无约束条件</h2><p>以<em>Bukin</em>函数为例，其函数形式如下：</p>
<script type="math/tex; mode=display">
f(x)=100\sqrt {|x_2-0.01x_1^2|}+0.01|x_1+10|\\
~\\
x_1\in [-15, -5],\ x_2\in [-3,3]</script><p>已知该函数在$x^{*}=(-10,1)$时有最小值$0$。下面用粒子群算法求解最优值</p>
<p>该例中，粒子运动空间的维度为$2$，取种群规模为$100$，更新代数为$500$，速度范围为$[-1,1]，$自身权重因子$0.9$，自身认知常数$2.0$，社会认知常数$2.0$。程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PSO</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size, nVar, xMin, xMax, vMin, vMax, times</span>):</span><br><span class="line">        self.size = size								<span class="comment"># 种群规模</span></span><br><span class="line">        self.nVar = nVar								<span class="comment"># 空间维数</span></span><br><span class="line">        self.times = times								<span class="comment"># 迭代次数</span></span><br><span class="line">        self.x = np.zeros((size, nVar), dtype=<span class="built_in">float</span>)	<span class="comment"># 粒子坐标</span></span><br><span class="line">        self.v = np.zeros((size, nVar), dtype=<span class="built_in">float</span>)	<span class="comment"># 粒子速度</span></span><br><span class="line">        self.xMin = np.array(xMin, dtype = <span class="built_in">float</span>)		<span class="comment"># 粒子位置下限</span></span><br><span class="line">        self.xMax = np.array(xMax, dtype = <span class="built_in">float</span>)		<span class="comment"># 粒子位置上限</span></span><br><span class="line">        self.vMin = vMin								<span class="comment"># 粒子速度下限</span></span><br><span class="line">        self.vMax = vMax								<span class="comment"># 粒子速度上限</span></span><br><span class="line">        <span class="comment"># 粒子坐标与速度随机值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nVar):</span><br><span class="line">                self.x[i][j] = random.uniform(self.xMin[j], self.xMax[j])</span><br><span class="line">                self.v[i][j] = random.uniform(self.vMin, self.vMax)</span><br><span class="line">        <span class="comment"># 单个粒子最有值与全局最优值索引</span></span><br><span class="line">        self.pBest = self.x.copy()</span><br><span class="line">        self.gBest = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fitness</span>(<span class="params">self, x</span>):</span><br><span class="line">        x1 = x[<span class="number">0</span>]</span><br><span class="line">        x2 = x[<span class="number">1</span>]</span><br><span class="line">        f = <span class="number">100</span> * np.sqrt(np.<span class="built_in">abs</span>(x2 - <span class="number">0.01</span>*x1**<span class="number">2</span>)) + <span class="number">0.01</span> * np.<span class="built_in">abs</span>(x1 + <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, w, c1, c2</span>):</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(self.times):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (self.size):</span><br><span class="line">                <span class="comment"># 更新粒子速度</span></span><br><span class="line">                self.v[i] = w * self.v[i] + random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c1 * (self.pBest[i] - self.x[i]) + random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c2 * (self.pBest[self.gBest] - self.x[i])</span><br><span class="line">                <span class="comment"># 确保速度不超过上下限</span></span><br><span class="line">                self.v[i][self.v[i] &lt; self.vMin] = self.vMin</span><br><span class="line">                self.v[i][self.v[i] &gt; self.vMax] = self.vMax</span><br><span class="line">                <span class="comment"># 更新粒子位置</span></span><br><span class="line">                self.x[i] += self.v[i]</span><br><span class="line">                <span class="comment"># 确保位置不超过上下限</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.nVar):</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &gt; self.xMax[j]:</span><br><span class="line">                        self.x[i][j] = self.xMax[j]</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &lt; self.xMin[j]:</span><br><span class="line">                        self.x[i][j] = self.xMin[j]</span><br><span class="line">                <span class="comment"># 比较每个粒子的新的适应度与历史最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[i]):</span><br><span class="line">                    self.pBest[i] = self.x[i]</span><br><span class="line">                <span class="comment"># 比较当前粒子的新适应度与全局最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[self.gBest]):</span><br><span class="line">                    self.gBest = i</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.pBest[self.gBest])</span><br><span class="line">        <span class="built_in">print</span>(self.fitness(self.pBest[self.gBest]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 种群规模为100，更新500代</span></span><br><span class="line">    bukin = PSO(size=<span class="number">100</span>, nVar=<span class="number">2</span>, xMin=[-<span class="number">15</span>, -<span class="number">3</span>], xMax=[-<span class="number">5</span>, <span class="number">3</span>], vMin=-<span class="number">1</span>, vMax=<span class="number">1</span>, times=<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 自身权重因子0.9，自身认知常数2.0，社会认知常数2.0</span></span><br><span class="line">    bukin.update(w = <span class="number">0.9</span>, c1 = <span class="number">2.0</span>, c2 = <span class="number">2.0</span>)</span><br><span class="line">    bukin.display()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>筛选最优输出结果为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-10.77631364   1.16128901]</span><br><span class="line">0.0662286658094341</span><br></pre></td></tr></table></figure></p>
<h2 id="有约束条件"><a href="#有约束条件" class="headerlink" title="有约束条件"></a>有约束条件</h2><p>与模拟退火算法相同，在处理约束条件时我们依旧采用罚函数的思想，将约束条件转换为限制粒子飞行的因素。</p>
<script type="math/tex; mode=display">
min\ f(x)=0.4x_2 + x_1^2+x_2^2-x_1x_2+ \frac{1}{30}x_1^3\\
~\\
s.t.\ 
\begin{cases}
x_1+0.5x_2 \geq 0.4\\
0.5x_1+x_2 \geq 0.5\\
x_1\geq 0, x_2 \geq 0
\end{cases}</script><p>对于该例子，利用惩罚函数法，将约束条件转化为惩罚项，定义$P_1=(\min(x_1+0.5x_2-0.4,0))^2$，$P_2=(\min(0.5x_1+x_2-0.5,0))^2$，此时构造新的增广目标函数$min\ F(X,M_t)=f(X)+M_t(P_1+P_2)$，其中$M_t$为惩罚因子。</p>
<p>粒子运动空间的维度为$2$，取种群规模为$100$，更新代数为$500$，速度范围为$[-1,1]，$自身权重因子$0.9$，自身认知常数$2.0$，社会认知常数$2.0$。该例自变量没有上限，但我们可以粗略估计在最优解时自变量$x_1$，$x_2$都落在$[0,1.0]$内，因此将粒子坐标的上限设为$1.0$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PSO</span>:</span><br><span class="line">    <span class="comment"># 初始化参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size, dim, xMin, xMax, vMin, vMax, times</span>):</span><br><span class="line">        self.size = size							<span class="comment"># 种群规模</span></span><br><span class="line">        self.dim = dim								<span class="comment"># 空间维度</span></span><br><span class="line">        self.vMin = vMin							<span class="comment"># 粒子速度下限</span></span><br><span class="line">        self.vMax = vMax							<span class="comment"># 粒子速度上限</span></span><br><span class="line">        self.times = times							<span class="comment"># 迭代次数</span></span><br><span class="line">        self.xMin = np.array(xMin, dtype = <span class="built_in">float</span>)	<span class="comment"># 粒子坐标下限</span></span><br><span class="line">        self.xMax = np.array(xMax, dtype = <span class="built_in">float</span>)	<span class="comment"># 粒子坐标上限</span></span><br><span class="line">        <span class="comment"># 粒子的位置与速度初始值均为随机值</span></span><br><span class="line">        self.x = np.zeros((size, dim), dtype = <span class="built_in">float</span>)</span><br><span class="line">        self.v = np.zeros((size, dim), dtype = <span class="built_in">float</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">                self.x[i][j] = random.uniform(self.xMin[j], self.xMax[j])</span><br><span class="line">                self.v[i][j] = random.uniform(self.vMin, self.vMax)</span><br><span class="line">        <span class="comment"># 单个粒子的最佳坐标和全局最佳坐标</span></span><br><span class="line">        self.pBest = self.x.copy()</span><br><span class="line">        self.gBest = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每一代的全局最优值</span></span><br><span class="line">        self.bestList = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># 带有惩罚项的适应度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fitness</span>(<span class="params">self, x, M</span>):</span><br><span class="line">        x1 = x[<span class="number">0</span>]</span><br><span class="line">        x2 = x[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 目标函数</span></span><br><span class="line">        fx = <span class="number">0.4</span>*x2 + x1**<span class="number">2</span> + x2**<span class="number">2</span> - x1*x2 + (<span class="number">1</span>/<span class="number">30</span>)*(x1**<span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 惩罚项</span></span><br><span class="line">        p1 = (<span class="built_in">min</span>(x1 + <span class="number">0.5</span>*x2 - <span class="number">0.4</span>, <span class="number">0</span>))**<span class="number">2</span></span><br><span class="line">        p2 = (<span class="built_in">min</span>(<span class="number">0.5</span>*x1 + x2 - <span class="number">0.5</span>, <span class="number">0</span>))**<span class="number">2</span></span><br><span class="line">        <span class="comment"># 增广函数</span></span><br><span class="line">        Fx = fx + M*(p1 + p2)</span><br><span class="line">        <span class="keyword">return</span> fx, Fx</span><br><span class="line">    <span class="comment"># 种群更新迭代</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, w, c1, c2</span>):</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(self.times):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.size):</span><br><span class="line">                <span class="comment"># 更新粒子速度</span></span><br><span class="line">                self.v[i] = w*self.v[i] + c1 * random.uniform(<span class="number">0</span>, <span class="number">1</span>) * (self.pBest[i] - self.x[i]) + c2 * random.uniform(<span class="number">0</span>, <span class="number">1</span>) * (self.pBest[self.gBest] - self.x[i])</span><br><span class="line">                self.v[i][self.v[i] &lt; self.vMin] = self.vMin</span><br><span class="line">                self.v[i][self.v[i] &gt; self.vMax] = self.vMax</span><br><span class="line">                <span class="comment"># 更新粒子坐标</span></span><br><span class="line">                self.x[i] = self.x[i] + self.v[i]</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.dim):</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &gt; self.xMax[j]:</span><br><span class="line">                        self.x[i][j] = self.xMax[j]</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &lt; self.xMin[j]:</span><br><span class="line">                        self.x[i][j] = self.xMin[j]</span><br><span class="line">                <span class="comment"># 惩罚因子</span></span><br><span class="line">                M = t**(<span class="number">3</span>/<span class="number">2</span>)</span><br><span class="line">                <span class="comment"># 目标函数值与适应度</span></span><br><span class="line">                fx, Fx = self.fitness(self.x[i], M)</span><br><span class="line">                pBest_fx, pBest_Fx =  self.fitness(self.pBest[i], M)</span><br><span class="line">                gBest_fx, gBest_Fx = self.fitness(self.pBest[self.gBest], M)</span><br><span class="line">                <span class="comment"># 更新单个粒子最优坐标与全局最优坐标</span></span><br><span class="line">                <span class="keyword">if</span> Fx &lt; pBest_Fx:</span><br><span class="line">                    self.pBest[i] = self.x[i]</span><br><span class="line">                <span class="comment"># 比较当前粒子的新适应度与全局最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> Fx &lt; gBest_Fx:</span><br><span class="line">                    self.gBest = i</span><br><span class="line">            self.bestList.append(self.fitness(self.pBest[self.gBest], M)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.pBest[self.gBest])</span><br><span class="line">        <span class="built_in">print</span>(self.fitness(self.pBest[self.gBest], <span class="number">0</span>)[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 绘图</span></span><br><span class="line">        plt.plot(self.bestList)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pso = PSO(size=<span class="number">100</span>, dim=<span class="number">2</span>, xMin=[<span class="number">0</span>, <span class="number">0</span>], xMax=[<span class="number">1.0</span>, <span class="number">1.0</span>], vMin=-<span class="number">1</span>, vMax=<span class="number">1</span>, times=<span class="number">500</span>)</span><br><span class="line">    pso.update(w = <span class="number">0.9</span>, c1 = <span class="number">2.0</span>, c2 = <span class="number">2.0</span>)</span><br><span class="line">    pso.display()</span><br></pre></td></tr></table></figure>
<p>输出结果为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0.34072776 0.32958779]</span><br><span class="line">0.2455774890528109</span><br></pre></td></tr></table></figure></p>
<div align=center><img src="https://pic.imgdb.cn/item/63115e1116f2c2beb1bd456a.png"></div>
从图像中可以看出，在20代左右全局最优值已经趋于稳定，并接近最终解。**需要注意，从图像上看，最初几代的全局最优值要比最终结果更小，这是因为该图像纵坐标表示优化目标函数值$f(x)$，不包含惩罚项。这时函数值虽然更小，但变量并不满足约束条件。** 这与解空间上限的取值有关，读者不妨取其它值试验，观察图像的差异。

# 改进算法
## 二阶粒子群算法
粒子群算法是一种简单高效的优化算法，但其很容易陷入局部最优。

在第$t$代，粒子$i$的实际运动速率为$v_i^t$为$x_i^t-x_i^{t-1}$，若仅考虑粒子向个体最佳位置*pbest*运动，粒子的速度变化率为
$$
v_i^{t+1}-v_i^t=(P_i-x_i^t)-(x_i^t-x_i^{t-1})=P_i-2x_i^t+x_i^{t-1}
$$
仅考虑粒子向全局最佳位置*gbest*运动，粒子的速度变化率为
$$
v_i^{t+1}-v_i^t=(P_g-x_i^t)-(x_i^t-x_i^{t-1})=P_g-2x_i^t+x_i^{t-1}
$$
当同时考虑个体最佳位置与全局最佳位置的影响时，微粒的速度变化率应为上述两种情况的随机加权，并在算法中引入**惯性权重$w$** 来平衡算法的全局搜索能力与局部搜索能力。设$\varphi_1$为$c_1r_1$，$\varphi_2$为$c_1r_1$ ,得到二阶PSO算法的进化方程如下
$$
v_i^{t+1}=wv_i^t+\varphi_1(P_i-2x_i^t+x_i^{t-1})+\varphi_2(P_g-2x_i^t+x_i^{t-1})\\
~\\
x_i^{t+1}=x_i^t+v_i^{t+1}
$$

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update2d</span>(<span class="params">self, w, c1, c2</span>):</span><br><span class="line">        <span class="keyword">for</span> iterator <span class="keyword">in</span> <span class="built_in">range</span>(self.times):</span><br><span class="line">            <span class="comment"># 上一代粒子的位置，初始为所有粒子的初始位置</span></span><br><span class="line">            xPrev = self.x.copy()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (self.size):</span><br><span class="line">                <span class="comment"># 更新粒子速度</span></span><br><span class="line">                self.v[i] = w * self.v[i] + random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c1 * (self.pBest[i] - <span class="number">2</span>*self.x[i] + xPrev[i]) + random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c2 * (self.pBest[self.gBest] - <span class="number">2</span>*self.x[i] + xPrev[i])</span><br><span class="line">                <span class="comment"># 确保速度不超过上下限</span></span><br><span class="line">                self.v[i][self.v[i] &lt; self.vMin] = self.vMin</span><br><span class="line">                self.v[i][self.v[i] &gt; self.vMax] = self.vMax</span><br><span class="line">                <span class="comment"># 更新粒子位置</span></span><br><span class="line">                self.x[i] += self.v[i]</span><br><span class="line">                <span class="comment"># 确保位置不超过上下限</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.nVar):</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &gt; self.xMax[j]:</span><br><span class="line">                        self.x[i][j] = self.xMax[j]</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &lt; self.xMin[j]:</span><br><span class="line">                        self.x[i][j] = self.xMin[j]</span><br><span class="line">                <span class="comment"># 比较每个粒子的新的适应度与历史最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[i]):</span><br><span class="line">                    self.pBest[i] = self.x[i]</span><br><span class="line">                <span class="comment"># 比较当前粒子的新适应度与全局最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[self.gBest]):</span><br><span class="line">                    self.gBest = i</span><br></pre></td></tr></table></figure>
仍以*Bukin*函数为例，筛选出的最优结果为
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-10.39337108   1.08022159]</span><br><span class="line">0.0219605855713847</span><br></pre></td></tr></table></figure>
相较于标准的粒子群算法，二阶粒子群算法仅对进化方程进行改动，改进效果并不明显。

## 二阶振荡粒子群算法
为了进一步提高群体的多样性，可考虑在二阶粒子群算法中引入一个振荡环节，来改善算法的全局收敛性。其进化方程描述如下
$$
v_i^{t+1}=wv_i^{t}+\varphi_1(P_i-(1+\xi_1)x_i^t+\xi_2x_i^{t-1})+\varphi_2(P_g-(1+\xi_3)x_i^t+\xi_4x_i^{t-1})\\
~\\
x_i^{t+1}=x_i^t+v_i^{t+1}
$$
当$0<\xi_2<\frac{1+\xi_1}{2}$，$0<\xi_4<\frac{1+\xi_3}{2}$，$0<\xi_1<1$，$0<\xi_3<1$时，算法振荡收敛；当$\xi_1<\xi_2-1$，$\xi_3<\xi_4-1$，$0<\xi_2<1$，$0<\xi_4<1$时，算法渐进收敛。

<div align=center><img src="https://pic.imgdb.cn/item/63115e3016f2c2beb1bd5286.png"></div>

<div align=center><img src="https://pic.imgdb.cn/item/63115e3416f2c2beb1bd5413.png"></div>



<p>在全局算法中，一般地，希望算法前期有较高的搜索能力以得到合适的种子，而在后期有较高的开发能力以加快收敛速度。也就是希望算法前期全局搜索能力较强，后期剧不搜索能力较强。因此，PSO算法做如下更改：</p>
<blockquote>
<p><strong>$step\ 4$  依据二阶振荡PSO进化方程更新微粒的速度与位置。当前代数$t&lt;G_{max}/2$时，取$0&lt;\xi_2&lt;\frac{1+\xi_1}{2}$，$0&lt;\xi_4&lt;\frac{1+\xi_3}{2}$，$0&lt;\xi_1&lt;1$，$0&lt;\xi_3&lt;1$；当前代数$t\geq G_{max}/2$时，取$\xi_1&lt;\xi_2-1$，$\xi_3&lt;\xi_4-1$，$0&lt;\xi_2&lt;1$，$0&lt;\xi_4&lt;1$.</strong></p>
</blockquote>
<p>二阶振荡粒子群算法程序如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update2dvib</span>(<span class="params">self, w, c1, c2</span>):</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(self.times):</span><br><span class="line">            <span class="comment"># 上一代粒子的位置，初始为所有粒子的初始位置</span></span><br><span class="line">            xPrev = self.x.copy()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (self.size):</span><br><span class="line">                <span class="comment"># 设置参数</span></span><br><span class="line">                phi1 = random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c1</span><br><span class="line">                phi2 = random.uniform(<span class="number">0</span>, <span class="number">1</span>) * c2</span><br><span class="line">                <span class="comment"># 振荡因子在前半段和后半段取值不同</span></span><br><span class="line">                <span class="keyword">if</span> t &lt; self.times/<span class="number">2</span>:</span><br><span class="line">                    xi1 = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                    xi3 = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                    xi2 = random.uniform(<span class="number">0</span>, (<span class="number">1</span> + xi1)/<span class="number">2</span>)</span><br><span class="line">                    xi4 = random.uniform(<span class="number">0</span>, (<span class="number">1</span> + xi3)/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    xi2 = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                    xi4 = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                    xi1 = random.uniform(<span class="number">0</span>, xi2 - <span class="number">1</span>)</span><br><span class="line">                    xi3 = random.uniform(<span class="number">0</span>, xi4 - <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 二阶振荡粒子群算法进化方程</span></span><br><span class="line">                self.v[i] = w * self.v[i] + phi1 * (self.pBest[i] - (<span class="number">1</span>+xi1)*self.x[i] + xi2 * xPrev[i]) + phi2 * (self.pBest[self.gBest] - (<span class="number">1</span>+xi3)*self.x[i] + xi4 * xPrev[i])</span><br><span class="line">                <span class="comment"># 确保速度不超过上下限</span></span><br><span class="line">                self.v[i][self.v[i] &lt; self.vMin] = self.vMin</span><br><span class="line">                self.v[i][self.v[i] &gt; self.vMax] = self.vMax</span><br><span class="line">                <span class="comment"># 更新粒子位置</span></span><br><span class="line">                self.x[i] += self.v[i]</span><br><span class="line">                <span class="comment"># 确保位置不超过上下限</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.nVar):</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &gt; self.xMax[j]:</span><br><span class="line">                        self.x[i][j] = self.xMax[j]</span><br><span class="line">                    <span class="keyword">if</span> self.x[i][j] &lt; self.xMin[j]:</span><br><span class="line">                        self.x[i][j] = self.xMin[j]</span><br><span class="line">                <span class="comment"># 比较每个粒子的新的适应度与历史最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[i]):</span><br><span class="line">                    self.pBest[i] = self.x[i]</span><br><span class="line">                <span class="comment"># 比较当前粒子的新适应度与全局最佳适应度</span></span><br><span class="line">                <span class="keyword">if</span> self.fitness(self.x[i]) &lt; self.fitness(self.pBest[self.gBest]):</span><br><span class="line">                    self.gBest = i</span><br></pre></td></tr></table></figure><br>依旧以<em>Bukin</em>函数为例，筛选出的最优结果为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-10.   1.]</span><br><span class="line">0.0</span><br></pre></td></tr></table></figure><br>可以看到结果非常接近标准最优解，这说明二阶振荡PSO算法相较于二阶PSO算法与标准PSO算法精度得到很大提升。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/398856271">数学建模：非常通俗易懂的粒子群算法（PSO）入门 - 知乎 (zhihu.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=494215">A new optimizer using particle swarm theory</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96">粒子群优化 - 维基百科，自由的百科全书 (wikipedia.org)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sfu.ca/~ssurjano/bukin6.html">Bukin Function N. 6 (sfu.ca)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnki.com.cn/Article/CJFDTOTAL-JFYZ200711004.htm">二阶微粒群算法—《计算机研究与发展》2007年11期 (cnki.com.cn)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnki.com.cn/Article/CJFDTotal-JSGG201909021.htm">改进的二阶振荡粒子群算法—《计算机工程与应用》2019年09期 (cnki.com.cn)</a></li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>作者:</span>
                        <span>Zhou Yee</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/python/"># python</a>
                    
                        <a href="/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"># 数学建模</a>
                    
                        <a href="/tags/%E6%99%BA%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"># 智能优化算法</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/09/05/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/">遗传算法</a>
            
            
            <a class="next" rel="next" href="/2022/08/23/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/">模拟退火算法</a>
            
        </section>


    </article>
</div>

  
 <div id="gitalk-container"></div>  
 <link rel="stylesheet" href="//unpkg.com/gitalk/dist/gitalk.css">

<script src="//unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>

<div id="gitalk-container"></div>

<script type="text/javascript">

 var gitalk = new Gitalk({

 clientID: '86994a143adea299d26c',

 clientSecret: '4651662508f77e12032fecb76d7c06ec1b29d78d',

 repo: 'cszhouY.github.io',

 owner: 'cszhouY',

 admin: 'cszhouY',

 id: md5(location.pathname), 

 labels: 'Gitalk'.split(',').filter(l => l),

 perPage: 10,

 pagerDirection: 'last',

 createIssueManually: true,

 distractionFreeMode: false

 })

 gitalk.render('gitalk-container')

</script>
  


            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Zhou Yee | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>